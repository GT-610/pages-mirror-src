<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>随便讲讲 Rust 的 “宏”</title>
    <link href="/2024/03/28/rust-macro/"/>
    <url>/2024/03/28/rust-macro/</url>
    
    <content type="html"><![CDATA[<p>最近在看《通过例子学 Rust》，真切感受到了 Rust <del>有多么难学</del>设计有多么精巧。作为一门安全性和效率优先的编程语言，Rust 的语法个人感觉是半 C 半 Python，但结构上明显比二者都复杂。</p><p>在写第一个语句 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br></code></pre></td></tr></table></figure><p>的时候，我很好奇为什么 <code>println</code> 后面要加一个感叹号 <code>!</code>。查阅后得知，这是一种 Rust <strong>宏</strong>。</p><h2 id="什么是宏？"><a href="#什么是宏？" class="headerlink" title="什么是宏？"></a>什么是宏？</h2><p>在 Rust 中，<em>宏（macros）</em> 是一种<strong>元编程的工具</strong>，允许你在编译时<strong>对代码进行模式匹配、转换和生成</strong>。宏允许你编写一些特定的代码模板，在编译时根据这些模板生成具体的代码。这使得你可以编写更加灵活、通用和高效的代码。</p><p>其实说得简单点，这个宏和 C&#x2F;C++ 中的宏定义是一个性质的，起到<strong>片段替换</strong>的一个作用。</p><p>Rust 中的宏有两种宏：<strong>声明式宏</strong>、<strong>过程宏</strong>。</p><h2 id="声明式宏（declarative-macros）"><a href="#声明式宏（declarative-macros）" class="headerlink" title="声明式宏（declarative macros）"></a>声明式宏（declarative macros）</h2><p>声明式宏也称为 <em><code>macro_rules!</code> 宏</em>，它允许你定义模式和替换规则，用于在代码中执行简单的文本替换。声明式宏类似于 C 语言中的宏替换，但更加强大和类型安全。声明式宏可以使用模式匹配、重复、递归等功能来定义宏，并且可以在宏中执行一些基本的代码转换。</p><p>声明式宏，顾名思义，是可以<strong>由用户自己声明的</strong>，声明时也可以调用其他已经声明好的宏。</p><p>比如我声明一个 <code>say_hello</code> 宏，让它去固定输出 <code>Hello, World!</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> say_hello &#123;<br>    () =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我需要使用的时候，就这样子调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    say_hello!();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果就是这样的：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">Hello,</span> World!<br></code></pre></td></tr></table></figure><h3 id="对比：Rust-声明式宏-vs-C-语言宏定义"><a href="#对比：Rust-声明式宏-vs-C-语言宏定义" class="headerlink" title="对比：Rust 声明式宏 vs C 语言宏定义"></a>对比：Rust 声明式宏 vs C 语言宏定义</h3><ol><li><p>模式匹配和重复</p><p> Rust 的声明式宏允许使用<strong>模式匹配和重复</strong>来定义更复杂的模板。你可以使用 <code>match</code>、<code>if</code>、<code>for</code> 等语法来对输入的 <code>token</code> 流进行匹配和处理。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> print_range &#123;<br>    ($start:expr, $end:expr) =&gt; &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> $start..$end &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>        &#125;<br>    &#125;;<br>&#125;<br><br>print_range!(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p> 我可以直接在声明宏里面使用一个 for 循环，编译器预处理时候也知道这是个 for 循环。其实宏做到这样子，我个人感觉已经很接近函数了。</p><p> C 语言的宏定义也支持简单的模式匹配和重复，但功能相对受限，<strong>只能进行简单的文本替换和展开</strong>。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_RANGE(start, end) \</span><br><span class="hljs-meta">for (int i = start; i &lt; end; i++) &#123; \</span><br><span class="hljs-meta">    printf(<span class="hljs-string">&quot;%d\n&quot;</span>, i); \</span><br><span class="hljs-meta">&#125;</span><br><br>PRINT_RANGE(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p> 预处理的时候，编译器并不知道这个宏定义里面的语句是一个 for 循环。它只知道预处理的时候等价替换就是的了。</p><p> 这样看来 Rust 的声明宏确实要更加灵活，我感觉已经可以成为半个函数了。</p></li><li><p>类型安全和错误检查：</p><p> Rust 的声明式宏在编译时可以进行类型检查和错误检查，可以避免一些常见的错误。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> divide &#123;<br>    ($numerator:expr, <span class="hljs-number">0</span>) =&gt; &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;division by zero&quot;</span>);<br>    &#125;;<br>    ($numerator:expr, $denominator:expr) =&gt; &#123;<br>        $numerator / $denominator<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = divide!(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p> C 语言的宏定义没有类型检查和错误检查，需要自己去写，像这样一个除数为 0 的简单情况，如果不做处理，可能会导致一些潜在的错误。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DIVIDE(numerator, denominator) \</span><br><span class="hljs-meta">(denominator == 0 ? (fprintf(stderr, <span class="hljs-string">&quot;division by zero\n&quot;</span>), exit(EXIT_FAILURE), 0) : (numerator / denominator))</span><br><br><span class="hljs-type">int</span> result = DIVIDE(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p> 其实这个问题还是比较像第一条的，对于一些小的代码片段，也许我们不会太关注这个问题，但是一旦项目比较大，类型检查和错误检查就比较重要了。</p></li><li><p>代码生成和抽象：</p><p> Rust 的声明式宏可以生成更复杂和灵活的代码，允许对输入进行更多的操作和转换。</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> vec_of_strings &#123;<br>    ($($elem:expr),*) =&gt; &#123;<br>        <span class="hljs-built_in">vec!</span>[$($elem.<span class="hljs-title function_ invoke__">to_string</span>()),*]<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = vec_of_strings![<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];<br></code></pre></td></tr></table></figure><p> C 语言的宏定义主要用于文本替换，功能相对较弱，难以实现复杂的代码生成和抽象。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VEC_OF_STRINGS(elem1, elem2) \</span><br><span class="hljs-meta">&#123;elem1, elem2&#125;</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* v[] = VEC_OF_STRINGS(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><p>其实这几条说到底也就是， Rust 的声明宏不像 C 的宏替换那样就是个简单的文本替换，它的功能更加丰富。</p><h2 id="过程宏（procedural-macros）"><a href="#过程宏（procedural-macros）" class="headerlink" title="过程宏（procedural macros）"></a>过程宏（procedural macros）</h2><p>过程宏通常以<strong>函数</strong>的形式定义，并接收一个或多个输入 token 流，然后根据这些输入生成新的代码。过程宏可以在代码的语法树级别进行操作，因此可以实现更高级的代码转换和分析。</p><p>过程宏分为三种类型：</p><h3 id="属性宏-Attribute-Macros"><a href="#属性宏-Attribute-Macros" class="headerlink" title="属性宏 (Attribute Macros)"></a>属性宏 (Attribute Macros)</h3><p>属性宏允许你在代码上方使用类似于注解的语法来应用宏，比如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br></code></pre></td></tr></table></figure><p>就是一个常见的属性宏，用于自动为结构体或枚举类型实现 <code>Debug</code> trait。</p><h3 id="函数宏-Function-like-Macros"><a href="#函数宏-Function-like-Macros" class="headerlink" title="函数宏(Function-like Macros)"></a>函数宏(Function-like Macros)</h3><p>函数宏类似于声明式宏，但完全以<strong>函数</strong>的形式定义，可以更灵活地处理输入 token 流并生成代码。</p><h3 id="自定义派生宏-Custom-Derive-Macros"><a href="#自定义派生宏-Custom-Derive-Macros" class="headerlink" title="自定义派生宏 (Custom Derive Macros)"></a>自定义派生宏 (Custom Derive Macros)</h3><p>自定义派生宏允许编写用于自动实现 trait 或其他行为的宏，使得你可以为类型自动生成通用的实现代码。</p><p>刚刚提到的 <code>print!()</code> 就是一种过程宏。其实我也很好奇，几乎所有语言中，打印标准输出是被设计为一个<strong>函数</strong>的，而 Rust 为什么要采用宏这个设计方式。这个下文再聊。</p><h2 id="为什么标准输出被定义为一个宏？"><a href="#为什么标准输出被定义为一个宏？" class="headerlink" title="为什么标准输出被定义为一个宏？"></a>为什么标准输出被定义为一个宏？</h2><p>我们先来看一下 Rust 源码中对 <code>print!()</code> 宏的定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[macro_export]</span><br><span class="hljs-meta">#[stable(feature = <span class="hljs-string">&quot;rust1&quot;</span>, since = <span class="hljs-string">&quot;1.0.0&quot;</span>)]</span><br><span class="hljs-meta">#[cfg_attr(not(test), rustc_diagnostic_item = <span class="hljs-string">&quot;print_macro&quot;</span>)]</span><br><span class="hljs-meta">#[allow_internal_unstable(print_internals)]</span><br><span class="hljs-built_in">macro_rules!</span> print &#123;<br>    ($($arg:tt)*) =&gt; &#123;&#123;<br>        $crate::io::_print($crate::<span class="hljs-built_in">format_args!</span>($($arg)*));<br>    &#125;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于为什么 print 是个宏，<a href="https://stackoverflow.com/questions/67509637/what-benefits-are-there-with-making-println-a-macro">Stack Overflow</a> 上也有人提出了这个问题。我的理解是：</p><ol><li><p>避免移动语义问题</p><p> 在 Rust 中，过程宏可以自动引用其参数，即使参数在调用宏的代码中已经被使用过，也<strong>不会产生移动语义的问题</strong>。这是因为过程宏在编译时<strong>操作代码的语法树</strong>，而不是在运行时处理值的拷贝和移动。</p><p> 对于普通的函数或方法，参数的所有权传递是显式的，一旦参数被使用，它就会被移动并在后续代码中不可再用。</p><p> 这实际上是一个 Rust 所有权的问题。在 Rust 中，当一个值被传递给一个函数或者移动到另一个变量时，它的<strong>所有权就会转移</strong>到接收它的函数或者变量上。这种所有权转移被称为<em>移动（move）</em>。一旦值的所有权被移动，原始变量将<strong>不能再继续使用</strong>它。</p><p> 也就是说，每个变量对于函数来说，<strong>只能用一次</strong>。当你调用一个函数并将一个拥有所有权的值传递给它时，函数可能会<strong>消费</strong>这个值并且<strong>不能再继续使用</strong>它。这是为了<strong>确保内存安全</strong>和<strong>避免悬垂指针</strong>的问题而设计的。所有权的问题，以后我单写一篇文章讲。</p><p> 我们以一个简单的日志记录为例，我们先用过程宏去实现：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">macro_rules!</span> log &#123;<br>    ($level:expr, $($arg:tt)*) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, $level, <span class="hljs-built_in">format_args!</span>($($arg)*));<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-string">&quot;An error occurred&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    log!(<span class="hljs-string">&quot;ERROR&quot;</span>, <span class="hljs-string">&quot;Error message: &#123;&#125;&quot;</span>, message);<br>    <span class="hljs-comment">// 这里仍然可以继续使用 message</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Continuing to use message: &#123;&#125;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们再用函数等价替换一下，看看会怎么样：</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">log</span>(level: &amp;<span class="hljs-type">str</span>, message: <span class="hljs-type">String</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, level, message);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">message</span> = <span class="hljs-string">&quot;An error occurred&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">&quot;ERROR&quot;</span>, message.<span class="hljs-title function_ invoke__">clone</span>());<br>    <span class="hljs-comment">// 尝试在此处继续使用 message</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Continuing to use message: &#123;&#125;&quot;</span>, message);<br>&#125;<br></code></pre></td></tr></table></figure><p> 因为 <code>log</code> 函数会获取 <code>message</code> 的所有权，所以在函数调用之后，<code>message</code> 将被移动，导致后续的使用产生<strong>编译错误</strong>。而使用过程宏的情况下，由于参数的传递是基于宏的文本替换，并不会导致所有权的转移，因此后续对 <code>message</code> 的使用不会产生问题。</p><p> 很显然，几乎所有的场景下，标准输出都是需要重复输出一些变量内容的，那么你也只能使用过程宏，而不能用一次性的函数。</p></li><li><p>接受任意数量的参数</p><p> 过程宏可以接受<strong>任意数量</strong>的参数，这使得它们更加灵活和通用。你可以编写接受任意数量参数的宏来处理不同的场景。</p><p> 而普通函数或方法的参数数量是<strong>固定</strong>的，若用函数实现，要么需要为每种情况都编写不同的函数或方法，要么想尽办法把各种情况转换成统一参数数量和格式的形式。</p></li><li><p>编译前就进行格式验证</p><p> 过程宏可以在编译时<strong>验证格式字符串和参数的匹配</strong>，不匹配就不编译通过。C 语言中的 <code>printf</code> 函数在运行时才检查，运行的时候万一不匹配或者出现意料之外的结果，就很可能导致运行时出现 bug。</p></li></ol><p>当然这些只是 Rust 宏的一个很基础的部分，还有很多东西需要学习。很多东西也只是我自己的一个理解，如果这篇文章有什么错误或者不足，欢迎友好指出。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust 语言</tag>
      
      <tag>宏</tag>
      
      <tag>macro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019 年 3 月 计算机二级 C 语言 错题整理</title>
    <link href="/2024/03/27/ncre-2-1903/"/>
    <url>/2024/03/27/ncre-2-1903/</url>
    
    <content type="html"><![CDATA[<ol><li><p>下列叙述中正确的是</p><p> A. 存储空间不连续的所有链表一定是非线性结构</p><p> B. 结点中有多个指针域的所有链表一定是非线性结构</p><p> C. 能顺序存储的数据结构一定是线性结构</p><p> <em>D. 带链的栈与队列是线性结构</em></p></li><li><p><code>sizeof(double)</code> 是</p><p> A. 一个双精度型表达式</p><p> <em>B. 一个整型表达式</em></p><p> C. 一个不合法的表达式</p><p> D. 一种函数调用</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C 语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机二级</tag>
      
      <tag>NCRE</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 年 3 月 和 2019 年 9 月 计算机二级 C 语言 错题整理</title>
    <link href="/2024/03/23/ncre-2-2003-1909/"/>
    <url>/2024/03/23/ncre-2-2003-1909/</url>
    
    <content type="html"><![CDATA[<ol><li><p>当数据库中数据总体逻辑结构发生变化，而应用程序不受影响，称为数据的</p><p> <em>A. 逻辑独立性</em></p><p> B. 物理独立性</p><p> C. 应用独立性</p><p> D. 空间独立性</p></li><li><p>程序是运行结果是：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span>(*s)[<span class="hljs-number">4</span>], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123; <br>    <span class="hljs-type">int</span> m, i;<br>    m = s[<span class="hljs-number">0</span>][k];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i][k] &gt; m) <br>            m = s[i][k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;, &#123;<span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>&#125;, &#123;<span class="hljs-number">31</span>, <span class="hljs-number">32</span>, <span class="hljs-number">33</span>, <span class="hljs-number">34</span>&#125;&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, fun(a, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <em>A. 31</em></p><p> B. 34</p><p> C. 4</p><p> D. 32</p><p> 这个程序是按<strong>行</strong>找的最大值，所以是在 <code>1, 11, 21, 31</code> 之间找最大值，结果也就是 <code>31</code>。</p></li><li><p>下列关于数据库设计的叙述中，正确的是</p><p> A. <em>在需求分析阶段建立数据字典</em></p><p> B. 在概念设计阶段建立数据字典</p><p> C. 在逻辑设计阶段建立数据字典</p><p> D. 在物理设计阶段建立数据字典</p><p> 数据字典是关于数据库中数据的描述，在<strong>需求分析</strong>阶段建立，是下一步进行概念设计的基础。</p></li><li><p>下列叙述中正确的是</p><p> A. 存储空间不连续的所有链表一定是非线性结构</p><p> B. 结点中有多个指针域的所有链表一定是非线性结构</p><p> C. 能顺序存储的数据结构一定是线性结构</p><p> <em>D. 带链的栈与队列是线性结构</em></p></li><li><p><code>sizeof(double)</code> 是</p><p> A. 一个双精度型表达式</p><p> <em>B. 一个整型表达式</em></p><p> C. 一个不合法的表达式</p><p> D. 一种函数调用</p></li><li><p>在关系 A（S，SN，D）和 B（D，CN，NM）中，A 的主关键字是 S，B 的主关键字是 D，则 D 是 A 的</p><p> <em>A. 外键（码）</em></p><p> B. 候选键（码）</p><p> C. 主键（码）</p><p> D. 候选键或主键</p><p> 候选键（Candidate Key）：在关系中能<strong>唯一标识元组</strong>的属性组称为候选键。也就是说，候选键<strong>是一组属性</strong>，能够<strong>唯一确定</strong>一条记录，而且<strong>没有冗余</strong>。在关系中<strong>可能存在多个候选键</strong>。</p><p> 主键（Primary Key）：从<strong>候选键中选择的一个</strong>作为主键。主键是用来<strong>唯一标识</strong>关系中的元组的属性（列），并且<strong>不能包含空值</strong>（NULL）。每个关系<strong>只能有一个主键</strong>。</p><p> 外键（Foreign Key）：在一个关系中，如果<strong>一个属性（或一组属性）是另一个关系的主键</strong>，那么这个属性（或属性组）就称为另一个关系的外键。外键建立了两个关系之间的<strong>引用</strong>关系，用来维护表与表之间的联系。</p></li><li><p>某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二又树中的叶子结点数为</p><p> A. 不存在这样的二叉树</p><p> <em>B. 200</em></p><p> C. 198</p><p> D. 199</p><p> 度为 2 的结点是指二叉树中拥有两个子节点的节点。在一个二叉树中，每个节点的度数可以是 0、1 或 2。度为 0 表示该节点是叶子节点，度为 1 表示该节点只有一个子节点，度为 2 表示该节点有两个子节点。</p><p> 现在我们知道这棵二叉树共有 399 个节点，其中有 199 个度为 2 的节点。我们可以利用以下关系来解决问题：</p><p> 设 N 为叶子节点数；<br> 根据二叉树性质，度为 2 的节点数加上度为 1 的节点数再加上叶子节点数应等于总节点数；</p><p> 通常情况下，当题目没有提及度为 1 的节点时，我们可以<strong>假设它们的数量为 0</strong>。</p><p> 因此，这道题中每个节点<strong>要么是度为 0 的叶子节点</strong>，<strong>要么是度为 2 的节点</strong>，所以总节点数等于度为 0 的叶子节点数加上度为 2 的节点数。</p><p> 根据上述关系，我们可以得到如下方程：</p><p> 度为 0 的叶子节点数 + 199（度为2的节点数） &#x3D; 399（总节点数）</p><p> 然后我们解方程，找到叶子节点数N：</p> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>199</mn><mo>=</mo><mn>399</mn><mspace linebreak="newline"></mspace><mi>N</mi><mo>=</mo><mn>200</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">N + 199 = 399 \\N = 200 \\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">9</span><span class="mord">9</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span></span><span class="mspace newline"></span></span></span><p> 因此，该二叉树中的叶子节点数为 200，选项 B 是正确答案。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C 语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机二级</tag>
      
      <tag>NCRE</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 年 3 月 和 2020 年 9 月 计算机二级 C 语言 错题整理</title>
    <link href="/2024/03/19/ncre-2-2103-2009/"/>
    <url>/2024/03/19/ncre-2-2103-2009/</url>
    
    <content type="html"><![CDATA[<ol><li><p>某二叉树的中序序列为 DCBAEFG，后序序列为 DCBGFEA，则该二叉树的深度为</p><p> A. 5</p><p> <em>B. 4</em></p><p> C. 3</p><p> D. 2</p><p> <a href="https://blog.csdn.net/chinesekobe/article/details/110874773">二叉树的先序、中序和后序</a></p></li><li><p>程序运行后的输出结果为：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>]=&#123;<span class="hljs-string">&quot;One*World&quot;</span>,<span class="hljs-string">&quot;One*Dream！&quot;</span>&#125;;<br>*p=str[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,&quot;</span>,<span class="hljs-built_in">strlen</span>(p));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,p);<br>&#125;<br></code></pre></td></tr></table></figure><p> A. <code>9</code>，<code>One*Dream！</code></p><p> <em>B. <code>10</code>，<code>One*Dream！</code></em></p><p> C. <code>9</code>，<code>One*World</code></p><p> D. <code>10</code>，<code>One*World</code></p></li></ol><p>  初始化的时候只能初始化为一个值，所以实际上 <code>str</code> 数组内的值为 <code>One*Dream！</code>。</p><ol start="3"><li>有三个关系 R，S 和 T 如下图所示，关系T违反了哪一类完整性约束（）</li></ol><p>  <img src="/2024/03/19/ncre-2-2103-2009/3.png" alt="第 3 题图"></p><p>  A.  实体完整性约束</p><p>  <em>B.  参照完整性约束</em></p><p>  C.  用户定义的完整性约束</p><p>  D.  以上三项</p><ul><li><p>实体完整性：若属性 A 是基本关系 R 的主属性，则 <strong>A 不能取空值</strong>。</p><p>检查和违约处理：</p><ol><li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</p></li><li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</p></li></ol></li></ul><p>  这里面 A 的值为 1，很显然不是空值。</p><ul><li>参照完整性：若属性 F 是基本关系 R 的外码，它与基本关系 S 的主码 K 相对应，则对于 R 中每个元组在 F 上的值要么为空值，要么等于 S 中某个元组的主码值。</li></ul><p>  很显然这里面是不满足值相等的。</p><ul><li>用户定义的完整性：比如唯一性、能否取空值等。</li></ul><ol start="4"><li><p>下面描述中正确的是</p><p> A. <em>好的软件设计应是高内聚低耦合</em></p><p> B. 内聚性和耦合性无关</p><p> C. 内聚性是指多个模块间相互连接的紧密程度</p><p> D. 耦合性是指一个模块内部各部分彼此结合的紧密程度</p><p> 内聚性是指<strong>一个模块内部各部分彼此结合的紧密程度</strong>，耦合性是指<strong>多个模块间相互连接的紧密程度</strong>。</p><p> 打个比方，内聚性就好像是<strong>一个家庭的团结友好程度</strong>，耦合性则是<strong>多个家庭之间的关联程度</strong>。</p><p> 一个家庭里面肯定是越和睦越好，但是多个家庭之间肯定要互相有一点防备的，不然一户人家出事了，其他家跟着“连坐”，这是对整个社区是不利的。</p><p> 程序里面也一样，一个模块之间的紧密度越高，程序的稳定性肯定是越好，但是模块之间应该只能有<strong>必要的关联</strong>，否则一旦一个模块出现了 bug 要修改，其他模块也必须要跟着修改，反而大大增加了工作量。低耦合也可以确保后序增加新功能的时候，尽量少地重构，也方便复用。所以常说一个好的程序是“<strong>高内聚、低耦合</strong>”。</p></li><li><p>下列叙述中错误的是</p><p> A. 在带链队列中，队头指针和队尾指针都是在动态变化的</p><p> <em>B. 在带链栈中，栈顶指针和栈底指针都是在动态变化的</em></p><p> C. 在带链栈中，栈顶指针是在动态变化的，但栈底指针是不变的</p><p> D. 在带链队列中，队头指针和队尾指针可以指向同一个位置</p></li></ol><ul><li><p>带链栈（Linked Stack）：带链栈是一种<strong>使用链表实现的栈</strong>结构。它通常包含一个<strong>指向链表顶部的指针</strong>，称为<em>栈顶指针</em>。栈的基本操作包括<em>入栈</em>（push）和<em>出栈</em>（pop）。在入栈操作中，新<strong>元素被添加到链表的头部</strong>，并<strong>更新栈顶指针</strong>指向该新元素；在出栈操作中，<strong>栈顶元素被移除</strong>，并<strong>更新栈顶指针</strong>指向下一个元素。因此，<strong>栈顶指针是在动态变化的</strong>，但<strong>栈底指针</strong>并<strong>不是常常存在或者不一定需要</strong>，因为栈底指针<strong>通常不被直接引用或改变</strong>。</p></li><li><p>带链队列（Linked Queue）：带链队列是一种<strong>使用链表实现的队列</strong>结构。它包含<strong>指向队列头部和尾部的指针</strong>，分别称为<em>队头指针</em>和<em>队尾指针</em>。队列的基本操作包括<em>入队</em>（enqueue）和<em>出队</em>（dequeue）。在入队操作中，新元素被添加到链表的尾部，并<strong>更新队尾指针</strong>指向该新元素；在出队操作中，队头元素被移除，并<strong>更新队头指针</strong>指向下一个元素。队头指针和队尾指针<strong>都是在动态变化</strong>的。在特殊情况下，队头指针和队尾指针<strong>可以指向同一个位置</strong>，表示队列中<strong>只有一个元素</strong>。</p></li></ul><ol start="6"><li><p>程序运行后的输出结果是</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; <br>i=~i; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);&#125;<br></code></pre></td></tr></table></figure><p> A. <code>0</code></p><p> B. <code>1</code></p><p> C. <code>8</code></p><p> <em>D. <code>-1</code></em></p><p> C 语言中，<code>~</code> 是<strong>按位取反</strong>操作符，也就是将所有的 <code>0</code> 换成 <code>1</code>。但要注意<strong>符号位</strong>也由 <code>0</code> 变成 <code>1</code>，因此结果是 <code>-1</code>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C 语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机二级</tag>
      
      <tag>NCRE</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 年 9 月 计算机二级 C 语言 错题整理</title>
    <link href="/2024/03/18/ncre-2-2109/"/>
    <url>/2024/03/18/ncre-2-2109/</url>
    
    <content type="html"><![CDATA[<ol><li><p>设循环队列的存储空间为 Q（1:50），初试状态为front&#x3D;rear&#x3D;50。经过一系列正常操作后，front-1&#x3D;rear。为了在该队列中寻找值最大的元素，在最坏的情况下需要比较的次数为</p><p> A. 0</p><p> B. 1</p><p> <em>C. 48</em></p><p> D. 49</p><p> 这道题的队列是一个<strong>循环队列</strong>，<code>front-1=near</code> 也就是说这个队列里有 49 个元素。最坏的情况下，<strong>最大值在队列末尾</strong>，则需要将49个元素<strong>一一比较</strong>，需要比 48 次。</p></li><li><p>下面不属于软件需求分析阶段任务的是</p><p> <em>A. 需求配置</em></p><p> B. 需求获取</p><p> C. 需求分析</p><p> D. 需求评审</p><p> 需求获取、需求分析、<strong>需求定义</strong>、需求评审</p></li><li><p>不属于对象构成成份的是</p><p> <em>A. 规则</em></p><p> B. 属性</p><p> C. 标识</p><p> D. 方法（或操作）</p><p> 对象是由描述该对象属性的数据以及可以对这些数据施加的所有操作封装在一起构成的统一体。一个对象通常可由<strong>对象名（标识）</strong>、<strong>属性</strong>和<strong>操作</strong>三部分组成。</p></li><li><p>在数据库中，产生数据不一致的根本原因是</p><p> <em>A. 数据冗余</em></p><p> B. 没有严格保护数据</p><p> C. 未对数据进行完整性控制</p><p> D. 数据存储量太大</p><p> 产生数据不一致的根本原因是<strong>数据冗余</strong>。</p></li><li><p>设有课程关系模式 R（C#,Cn,T,TA）（其中，C# 为课程号，Cn 为课程名，T 为教师名，TA 为教师地址），并且假定不同课程号可以有相同的课程名，每门课程只有一位任课教师，但每位教师可以有多门课程。关系 R 范式最高达到</p><p> A. 1NF</p><p> <em>B. 2NF</em></p><p> C. 3NF</p><p> D. BCNF</p><p> 这里有<a href="https://blog.csdn.net/weixin_43971764/article/details/88677688">一篇讲三种范式的文章</a>，总结起来也就是：</p><ul><li>第一范式：一对一</li><li>第二范式：<strong>满足第一范式</strong>，且全部的非主键列<strong>全部依赖于</strong>主键</li><li>第三范式：<strong>满足第二范式</strong>，且非主键列内<strong>没有传递依赖</strong></li></ul><p> 在这个例子中，课程号为<strong>主键</strong>对应后面三个非主键，所以满足第一范式；非主键（课程名、教师名、教师地址）均依赖于所有的主键（课程号不重复），所以满足第二范式；<strong>每个教师地址对应一个教师</strong>，也就是说在非主键列内，存在<strong>传递依赖</strong>，所以不满足第三范式。股这个 R 最高达到 2NF。</p></li><li><p>已知 <code>int a=6;</code>，则执行 <code>a+=a-=a*a;</code> 语句后，a 的值为（）。</p><p> A. 36</p><p> B. 0</p><p> C. -24</p><p> <em>D. -60</em></p><p> 根据优先级，执行顺序为：</p><ol><li><code>a*a</code>，此时表达式为 <code>a+=a-=36</code>；</li><li><code>a-=a</code>，此时 a 的值为 -30；</li><li><code>a+=a</code>，此时 a 的值为 -60。</li></ol></li><li><p>请阅读以下程序；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,y=<span class="hljs-number">0</span>,a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span>(x)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">switch</span>(y)<br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:a++;<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:b++;<span class="hljs-keyword">break</span>;<br>            &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            a++;b++;<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a=%d,b=%d\n&quot;</span>,a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p> 输出结果为：</p><p> <em>A. <code>a=2, b=1</code></em></p><p> B. <code>a=1, b=0</code></p><p> C. <code>a=1, b=1</code></p><p> D. <code>a=2, b=2</code></p><p> 这里有一个坑：<code>case 1</code> <strong>后面没有</strong> <code>break</code> <strong>语句</strong>。也就是说，<code>case 1</code> 里面的执行完之后，会继续执行 <code>case 2</code> 里面的语句。所以，a 被加了 2 次，b 被加了 1 次。</p></li><li><p>交换两个变量的值，不允许用临时变量，应该使用下列（）位运算符。</p><p> A. <code>&amp;</code></p><p> B. <code>^</code></p><p> C. <code>||</code></p><p> D. <code>~</code></p><p> 异或（<code>^</code>）可以交换两个变量的值，参考<a href="https://blog.csdn.net/heathyhuhu/article/details/12744407">这篇文章</a>：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>C 语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机二级</tag>
      
      <tag>NCRE</tag>
      
      <tag>C 语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0x3f3f3f3f - 神奇的“超级大的数”</title>
    <link href="/2024/03/18/0x3f3f3f3f/"/>
    <url>/2024/03/18/0x3f3f3f3f/</url>
    
    <content type="html"><![CDATA[<p>有时候做 BFS 和 DFS 之类的题，看题解的时候，经常能看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br></code></pre></td></tr></table></figure><p>一般去找最小值的题目的时候，我会定义一个<strong>很大很大的数</strong>，这样方便之后是逐步更新。但这个很大很大的数，究竟该多少呢？</p><p>我们并不知道输入的数据会有多大，所以我们也不好去定义这样一个大的数。<code>0x3f3f3f3f</code> 就解决了这样一个问题。</p><p><code>0x3f3f3f3f</code> 的十进制表示是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1061109567</mn></mrow><annotation encoding="application/x-tex">1061109567</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord">6</span><span class="mord">7</span></span></span></span>，这个数的大小是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span> 级别的，而一般的整型数据<strong>不会高于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span><strong>。因此，我们可以认为这个数是一个</strong>非常大的数</strong>。</p><h2 id="为什么用这个数？"><a href="#为什么用这个数？" class="headerlink" title="为什么用这个数？"></a>为什么用这个数？</h2><p>我的观点是，说简单点就是两个字：<strong>省事</strong>。这个数非常好记，拿来就用。</p><p>直到我看到这样一篇文章：</p><blockquote><p>由于一般的数据都不会大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，所以当我们把<strong>无穷大加上一个数据</strong>时，它<strong>并不会溢出</strong>（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上 <code>0x3f3f3f3f</code> + <code>0x3f3f3f3f</code> &#x3D; 2122219134，这非常大但却没有超过 32-bit int 的表示范围，所以 <code>0x3f3f3f3f</code> 还<strong>满足了我们“无穷大加无穷大还是无穷大”的需求</strong>。</p><p>最后，<code>0x3f3f3f3f</code> 还能给我们带来一个意想不到的额外好处：<br>如果我们想要将某个数组清零，我们通常会使用 <code>memset(a,0,sizeof(a))</code>，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用 <code>memset</code> 函数而得自己写循环了，因为 <code>memset</code> 是按字节操作的，它能够对数组清零是因为 <code>0</code> 的每个字节都是 <code>0</code>（一般我们只有赋值为 <code>-1</code> 和 <code>0</code> 的时候才使用它）。现在好了，如果我们将无穷大设为 <code>0x3f3f3f3f</code>，那么奇迹就发生了，<code>0x3f3f3f3f</code> 的每个字节都是 <code>0x3f</code>！所以要把一段内存全部置为无穷大，我们只需要 <code>memset(a,0x3f,sizeof(a))</code>。</p><footer><strong>【算法设计与数据结构】为何程序员喜欢将INF设置为 0x3f3f3f3f？</strong><cite><a href="https://blog.csdn.net/jiange_zh/article/details/50198097">blog.csdn.net/jiange_zh/article/details/50198097</a></cite></footer></blockquote><p>我又去查了查，发现也有人把 inf 设置为 <code>0x7fffffff</code>，这个数是 <strong>32 位整型的最大值</strong>，虽说这个数更大，但是已经到达了边界，无论是算法需要继续增加，还是设计程序时 bug 导致继续增加，都会导致<strong>溢出</strong>，增加风险。这样看来，<code>0x3f3f3f3f</code> 无疑要比这个数更合适的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>0x3f3f3f3f</code> 是一个非常大的数，实际上我们可以当成一个非常大的数去使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>算法竞赛</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 中的 lambda 表达式</title>
    <link href="/2024/03/17/python-lambda/"/>
    <url>/2024/03/17/python-lambda/</url>
    
    <content type="html"><![CDATA[<p>写 Python 作业的时候，<code>map()</code> 传入一个列表的二倍，第一个参数写 <code>number*2</code> 怎么也过不了：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs latex">Traceback (most recent call last):<br>  File &quot;/tmp/test.py&quot;, line 2, in &lt;module&gt;<br>    new<span class="hljs-built_in">_</span>list = list(map(numbers*2, numbers))<br>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br>TypeError: &#x27;list&#x27; object is not callable<br></code></pre></td></tr></table></figure><p>看来直接对列表乘 2 是不可行的。我问 ChatGPT，ChatGPT 告诉我用 <code>lambda</code> 表达式，那正好简单聊聊。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>lambda</code> 函数是一种小型、匿名、内联的函数，它可以具有任意数量的参数，但只能有一个表达式。</p><ol><li><p>小型：指的是 <code>lambda</code> 函数通常用于简单的功能需求，而不是复杂的函数逻辑。<code>lambda</code> 函数的简洁性也就是在这里体现的。</p></li><li><p>匿名：指的是 <code>lambda</code> 函数是一种<strong>没有显式名称</strong>的函数，它们在定义时<strong>不需要提供函数名</strong>，也<strong>只能</strong>通过<strong>赋值</strong>给变量或作为<strong>参数传递</strong>给其他函数来使用因此，<code>lambda</code> 函数通常用于<strong>临时</strong>、<strong>一次性</strong>的功能需求。</p></li><li><p>内联：指的是 <code>lambda</code> 函数的定义通常是在使用它们的地方直接进行，而不是在代码中单独定义。因此，<code>lambda</code> 函数可以被直接嵌入到表达式中，无需额外的函数定义。</p></li></ol><p>我个人理解：<code>lambda</code> 就是一个<strong>长得像表达式</strong>、<strong>用起来像表达式</strong>的一个<strong>函数</strong>。</p><p><del>其实我觉得这个匿名性质挺有趣的。。</del></p><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> arguments: expression<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><p><code>lambda</code> 是 Python 的关键字，用于定义 <code>lambda</code> 函数。</p></li><li><p><code>arguments</code> 是参数列表，可以包含<strong>零个</strong>或<strong>多个</strong>参数，但<strong>必须在冒号(<code>:</code>)前指定</strong>。</p></li><li><p><code>expression</code> 是一个表达式，用于计算并返回函数的结果。</p></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li><p>单个实参：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">f = <span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p> 它等价于：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x+<span class="hljs-number">10</span><br><br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p> 输出结果都是 <code>15</code>。</p><p> 这种简单东西相比于传统定义函数，是不是简洁很多？</p></li><li><p>多个实参：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">f = <span class="hljs-keyword">lambda</span> x,y: x*y<br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><p> 它等价于：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x*y<br><br><span class="hljs-built_in">print</span>(f(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure></li><li><p><code>lambda</code> 函数通常与内置函数如 <code>map()</code>、<code>filter()</code> 和 <code>reduce()</code> 一起使用，以便在集合上执行操作。其实这才是 <code>lambda</code> 表达式的真正用法。</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>squared = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, numbers))<br><span class="hljs-built_in">print</span>(squared)<br></code></pre></td></tr></table></figure><p> 输出结果：<code>[1, 4, 9, 16, 25]</code></p><p> 它等价于：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span><br><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>squared = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(square, numbers))<br><span class="hljs-built_in">print</span>(squared)<br></code></pre></td></tr></table></figure><p> 这里必须定义一个函数，是因为 <code>map()</code>、<code>list()</code>、<code>reduce()</code> 等函数的第一个参数，必须是<strong>一个函数</strong>，而不能是一个单独的表达式，因此我们如果想实现上述平方的效果，我们<strong>不能直接传入 <code>x**2</code><strong>，必须传入一个</strong>返回平方值的函数</strong>。使用 <code>lambda</code> 表达式和单独定义函数，那个简洁一目了然了吧。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>lambda</code> 表达式可以在某些<strong>必须传入函数</strong>的场合下，将一些<strong>简单的表达式</strong>封装为函数，方便调用，形式也很直观，可以说非常方便。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>lambda 表达式</tag>
      
      <tag>Python 函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gets() 函数的危险性 - 以及合理的替代</title>
    <link href="/2024/03/05/gets-function-replacement-in-c/"/>
    <url>/2024/03/05/gets-function-replacement-in-c/</url>
    
    <content type="html"><![CDATA[<p>起因是在 G++17 中图个省事，输入字符串的时候直接写了 <code>gets()</code>，但怎么也没法编译，提示没有这个函数。我之前了解过 <code>gets()</code> 函数有危险而且不建议使用，但好像也没说不能用吧……？ <del>（不建议用就别用）</del></p><p>于是我去查了以下 <code>gets()</code> 函数，发现事情绝对没有我想象的那么简单……</p><h2 id="什么是-gets-函数"><a href="#什么是-gets-函数" class="headerlink" title="什么是 gets() 函数"></a>什么是 <code>gets()</code> 函数</h2><p>C 库函数 <code>char *gets(char *str)</code> 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当<strong>读取到换行符</strong>时，或者到达<strong>文件末尾</strong>时，它会停止，具体<strong>视情况而定</strong>。</p><p>我们来看看它的原理：</p><blockquote><p><code>gets()</code> 函数的形参只有一个<strong>指针</strong>。它会从标准输入流中读字符到一块连续的内存地址空间中。这块地址空间的开始位置就是指针 <code>str</code> 指向的位置。当在输入流中遇到文件结束符 (<code>EOF</code>) 或者换行符 (<code>\n</code>) 时，读取操作结束。当读入换行符 (<code>\n</code>) 时，该字符不会被放入那块连续的地址空间中。在读取结束时， <code>gets()</code> 会自动在内存空间的末尾追加一个 <code>NULL</code> 字符。经过上述这些操作，对于程序员来说，这个函数得到的就是从标准输入进来的，以 <code>NULL</code> 字符结尾的 C 字符串。如果读入的字符流是一整行的话，行尾的换行符将会被舍去。</p><footer><strong>song33333</strong><cite><a href="https://blog.csdn.net/song33333/article/details/83541946">blog.csdn.net/song33333/article/details/83541946</a></cite></footer></blockquote><p>这看起来挺好：我不用提前考虑输入字符串的长度，只需要用空格和换行区分就可以了。</p><p>但是真的是这样吗？</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>gets</code> 的问题其实就在这个<strong>连续输入</strong>上。当使用 <code>gets()</code> 时，它会读取用户输入的字符，直到遇到换行符为止，并将这些字符<strong>存储到一个字符数组（缓冲区）中</strong>，然后返回缓冲区里的字符数据。</p><p><del>然而十行代码九行补漏洞，也没法阻止奇葩的用户需求。</del> 你不知道用户会输入多长的字符串，但是<strong>缓冲区的大小是有限的</strong>。如果用户输入的字符数量<strong>超过了缓冲区的大小</strong>，<code>gets()</code> 函数就会<strong>继续将字符写入缓冲区</strong>，导致<strong>缓冲区溢出</strong>。</p><p>缓冲区溢出发生时，超出缓冲区边界的字符会覆盖其他内存区域，这可能导致<strong>程序崩溃</strong>或者<strong>被攻击者利用</strong>。攻击者可以利用缓冲区溢出漏洞来修改程序的控制流，执行<strong>恶意代码</strong>或者获取敏感信息。</p><p>关于缓冲区溢出，可以看下<a href="https://zhuanlan.zhihu.com/p/545901268">这篇文章</a>，我觉得讲得还可以的。</p><p>正因为如此，按理来说使用 <code>gets()</code> 函数时必须特别小心，确保输入字符数量不会超出缓冲区的大小。但是，<strong>你怎么知道用户要输入多长呢？</strong></p><p>所以，与其不如想办法限制输入长度以防止缓冲区溢出，不如<strong>不用 <code>gets()</code> 函数</strong>。</p><p>也正因为如此，<code>gets()</code> 函数在 C 标准中被弃用，<strong>并于 C11 标准中正式移除</strong>。在 C11 标准中，gets() 函数被标记为 “obsolescent”（过时），并建议使用更安全的替代方案，如 <code>fgets()</code> 函数或者更推荐的 <code>fgets()</code> 的 C++ 等价函数 <code>std::cin.getline()</code>。由于 <code>gets()</code> 存在严重的安全漏洞，因此在更早的标准和编译器版本中，就已经开始警告开发者避免使用这个函数。例如，一些编译器在 C99 标准中就开始发出警告，而在 C11 标准中正式将其移除。</p><h2 id="那为什么最初的-C-标准还要引入-gets-呢？"><a href="#那为什么最初的-C-标准还要引入-gets-呢？" class="headerlink" title="那为什么最初的 C 标准还要引入 gets() 呢？"></a>那为什么最初的 C 标准还要引入 <code>gets()</code> 呢？</h2><p>以下是我的个人理解。</p><p>当初设计 <code>gets()</code> 函数并将其纳入 C 标准的主要原因是为了<strong>简化</strong>输入字符串的操作，使得程序员能够更方便地从标准输入中获取字符串数据。C 语言早期的时候，开发者还没考虑到那么多的安全性问题，而更注重的是编程语言的简洁性和易用性，而且安全性也并不是当时主要考虑的地方。因此，<code>gets()</code> 函数被设计为一种<strong>快速而方便</strong>的方法来读取用户输入的字符串。</p><p>然而，随着时间的推移和计算机科学的发展，人们开始意识到缓冲区溢出等安全漏洞的严重性。人们逐渐意识到，这个看起来很方便的函数，所引发的问题可能造成非常严重的安全后果。而这个缓冲区也不好再修修补补，况且经过这么多年发展，<code>gets()</code> 也不再是唯一一种读取字符串的方法，与其修这些问题，不如砍掉一了了之。</p><h2 id="替代-解决方案"><a href="#替代-解决方案" class="headerlink" title="替代 &#x2F; 解决方案"></a>替代 &#x2F; 解决方案</h2><p>其实要想实现 <code>gets()</code> 函数同样的效果也并不难，有很多方法都可以替代 <code>gets()</code>。这其中有的是通过<strong>限制输入长度</strong>实现的，也有的可以<strong>直接读取</strong>。</p><ol><li><p><code>fgets()</code> 函数</p><p> <code>fgets()</code> 可以从标准输入中读取一行字符串，并将其存储到指定大小的缓冲区中。与 <code>gets()</code> 不同，<code>fgets()</code> 允许指定要读取的字符数目，从而避免了缓冲区溢出的问题。</p><p> <code>fgets()</code> 也是普遍认可的一个 <code>gets()</code> 的替代。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">1000</span>]<br>fgets(a, <span class="hljs-keyword">sizeof</span>(a), <span class="hljs-built_in">stdin</span>);<br></code></pre></td></tr></table></figure><p> 将 <code>fgets()</code> 的写入流改为 <code>stdin</code> 即可向对应的字符串写入。</p></li><li><p><code>std::cin.getline()</code> (仅限 C++)</p><p> 在 C++ 中，可以使用 <code>std::cin.getline()</code> 函数来替代 <code>gets()</code>。它可以从标准输入中读取一行字符串，并将其存储到指定大小的缓冲区中。与 <code>gets()</code> 类似，<code>std::cin.getline()</code> 允许指定要读取的字符数目，从而避免了缓冲区溢出的问题。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>cin.<span class="hljs-built_in">getline</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br></code></pre></td></tr></table></figure></li><li><p><code>std::getline()</code></p><p> 在 C++ 中，也可以使用 <code>std::getline()</code> 函数来读取一行字符串，它更加灵活，可以读取任意长度的字符串，并将其存储到 <code>std::string</code> 对象中。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string line;<br><span class="hljs-built_in">getline</span>(cin, line);<br></code></pre></td></tr></table></figure></li><li><p><code>scanf()</code> + <code>&quot;%s&quot;</code></p><p> 可以在 <code>scanf()</code> 函数中使用格式化字符串来指定要读取的字符数量，并且建议使用 <code>%s</code> 格式，并指定字段宽度。这样可以确保 <code>scanf()</code> 函数不会读取超过指定长度的字符，从而避免了缓冲区溢出的风险。</p><p> 下面是一个使用 <code>scanf()</code> 函数读取字符串的示例，其中指定了字段宽度为 99：</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">100</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%99s&quot;</span>, a);<br></code></pre></td></tr></table></figure></li><li><p><code>scanf()</code> + <code>&quot;%[^\n]%*c&quot;</code></p><p> 这种方法是我在做一道题的时候用的，我觉得这个好处是可以在 C 中非常轻松地实现。</p><p> <code>%[^\n]</code> 格式表示<strong>读取除换行符以外的所有字符</strong>，直到遇到换行符为止。这样可以确保 <code>scanf()</code> 函数在读取完整行字符串时停止，而不会受到换行符的影响。</p><p> 然后，<code>%*c</code> 表示<strong>读取一个字符并丢弃它</strong>，也就是<strong>丢弃</strong>最后输入的<strong>换行符</strong>，这样可以清除输入缓冲区中的换行符，以防止它对后续输入产生干扰。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> a[<span class="hljs-number">10005</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%[^\n]%*c&quot;</span>, a);<br></code></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一句话就是：<code>gets()</code> 别用。</p><p>实际编写代码的时候，对于编译器的警告，<strong>一定不能忽略</strong>，最好仔细看一下能不能有更好的替代。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>C</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 动态规划 学习记录</title>
    <link href="/2024/02/29/dp-cpp/"/>
    <url>/2024/02/29/dp-cpp/</url>
    
    <content type="html"><![CDATA[<blockquote><p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 </p><footer><strong>维基百科</strong><cite><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a></cite></footer></blockquote><p>感觉维基给的定义有点抽象……？说简单点就是：</p><ol><li>把原来问题拆成<strong>小问题</strong>。</li><li><strong>逐个求解</strong>小问题，然后把答案保存起来。</li><li>再根据小问题的答案去反推原来问题的题解。</li></ol><p>核心就是：<strong>拆分子问题，记住答案，以减少重复的计算</strong>。</p><p>感觉还是看不懂……用网上一个很流行的例子去解释：</p><blockquote><p>A ： “1+1+1+1+1+1+1+1 &#x3D;？”<br>A ： “上面等式的值是多少”<br>B ： “8”<br>A : 在上面等式的左边写上 “1+” 呢？<br>A : “此时等式的值为多少”<br>B : 很快得出答案 “9”<br>A : “你怎么这么快就知道答案了”<br>A : “只要在8的基础上加1就行了”<br>A : “所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 ‘记住求过的解来节省时间’”</p></blockquote><p>也就是说我想办法<strong>记住过去的答案</strong>，这样我不用重复计算了。</p><h2 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h2><p>求解的方式有两种：<strong>自顶向下的备忘录法、自底向上</strong>。</p><p>举个例子：<em>斐波那契数列</em>。也就是说：<br> <blockquote><p> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&#x3D;</mo><mn>1</mn><mspace linebreak="newline"></mspace><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mi>i</mi><mi>b</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">Fib(0)&#x3D;1\<br>Fib(1)&#x3D;1\<br>Fib(n)&#x3D;Fib(n-1)+Fib(n-2)\</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&#x3D;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&#x3D;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&#x3D;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">i</span><span class="mord mathnormal">b</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span><span class="mspace newline"></span></span></span> </p></blockquote></p><p> 这个用递归可以直接解决：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n&gt;=<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 假设我输入 6，那么执行的递归树是这样：</p><pre><code class="mermaid" >graph TD;A["fib(6)"]-->B["fib(5)"]-->C2["fib(4)"]-->D3["fib(3)"]-->E4["fib(2)"]-->F5["fib(1)"];A-->C1["fib(4)"]-->D1["fib(3)"]-->E3["fib(2)"]-->F4["fib(1)"];B-->D2["fib(3)"]-->E2["fib(2)"]-->F3["fib(1)"];C1-->E1["fib(2)"]-->F1["fib(1)"];D1-->F2["fib(1)"];E1-->G1["fib(0)"];C2-->D4["fib(2)"]-->E5["fib(1)"];D2-->E6["fib(1)"];D3-->E7["fib(1)"];D4-->F6["fib(0)"];E2-->F8["fib(0)"];E3-->F7["fib(0)"];E4-->F9["fib(0)"]; </code></pre><p>从上面的递归树中可以看到，我运行一个 fib(6)，很多重复的节点，比如 fib(5)、fib(2)等等，被重复执行了很多次，这样的结果就是浪费时间。<br>这些重复的节点我们可以在遇到、计算之后，将其记录下来，后面再使用的时候直接把结果拉过来用，这样就节省了大量的时间。</p><p>我们分别用自顶向下和自底向上的方法，去解决斐波那契数列问题。</p><h3 id="自顶向下的备忘录法"><a href="#自顶向下的备忘录法" class="headerlink" title="自顶向下的备忘录法"></a>自顶向下的备忘录法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> memo[n]=&#123;<span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> memo[])</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(memo[n]!=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> memo[n];<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)memo[n]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> memo[n]=<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-1</span>,memo)+<span class="hljs-built_in">fib</span>(n<span class="hljs-number">-2</span>,memo);<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录法还是比较好理解的，先创建一个数组 memo 用来存储每个斐波那契数列对应的每一个值，然后再递归的时候，如果发现 memo 中<strong>存在</strong>之前已经计算好的值，则直接调用；如果还没有算过，则计算后保存在 memo 数组中。这样第n此计算 fib 时就不用重新递归了，效率大大提高。</p><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>备忘录法减少了重复的计算，但无论怎样，计算时还是递归去算的，既然我 fib(1)、fib(2)这样的都要算，那我为什么不先算好 fib(1)、fib(2)呢？</p><p>如果我从 fib(1) fib(2)开始，往上计算到目标的 fib（比如 fib(6)），这就是自底向上的动态规划，这种方法也是动态规划的核心：<strong>先计算子问题，再由子问题计算父问题。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-type">int</span> memo[n];<br>  memo[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>  memo[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>    memo[i]=memo[i<span class="hljs-number">-1</span>]+memo[i<span class="hljs-number">-2</span>];<br>&#125;<br>    <span class="hljs-keyword">return</span> memo[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>自底向上的计算方法，避免了递归产生的较高的栈开销，进一步降低了空间复杂度。<del>（正常人类手算也是这么算的吧）</del></p><p>由于实际参与循环的<strong>只有数组中的三个变量</strong>，如果中间计算的结果我们都不需要，那么我们还可以<strong>用三个变量代替整个数组</strong>，<strong>进一步压缩空间</strong>。</p><p>那么优化之后的代码应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>  <span class="hljs-type">int</span> memo[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> n;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>    memo[<span class="hljs-number">0</span>]=memo[<span class="hljs-number">2</span>]+memo[<span class="hljs-number">1</span>];<br>    memo[<span class="hljs-number">2</span>]=memo[<span class="hljs-number">1</span>];<br>    memo[<span class="hljs-number">1</span>]=memo[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> memo[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个非常简单的动态规划。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P1002-NOIP2002-普及组-过河卒"><a href="#P1002-NOIP2002-普及组-过河卒" class="headerlink" title="P1002 [NOIP2002 普及组] 过河卒"></a><a href="https://www.luogu.com.cn/problem/P1002">P1002 [NOIP2002 普及组] 过河卒</a></h3><p>（如有侵权请联系我删除）</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>棋盘上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 点有一个过河卒，需要走到目标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n, m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，同样马的位置坐标是需要给出的。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ipmwl52i.png"></p><p>现在要求你计算出卒从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 点能够到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一行四个正整数，分别表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 点坐标和马的坐标。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数，表示所有的路径条数。</p><h4 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h4><h5 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">6 6 3 3<br></code></pre></td></tr></table></figure><h5 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">6<br></code></pre></td></tr></table></figure><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">100 \%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">%</span></span></span></span> 的数据，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">1 \le n, m \le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo></mrow><annotation encoding="application/x-tex">0 \le</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span></span></span></span> 马的坐标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">\le 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>假如我这个人现在在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 这个位置，那么我可以怎么走到这个地方呢？我可以从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x-1,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 向右走过来，或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 向下走过来。当然第一行只能从左边向右到达，第一列只能从上边向下到达。</p><p>这一切的前提是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 能够到达（不位于马的控制点）。如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 是马的控制点，那么这个点的路径条数就是 0。</p><p>也就是说，人到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的路径条数，是到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x-1,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 的路径条数，和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的路径条数之和。</p><p>而初始点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 的路径条数为 1，我们就可以得到这样一个转移公式：</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>0</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mtext>不能到达</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mn>1</mn><mo separator="true">,</mo><mi>x</mi><mo>=</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>+</mo><mi>d</mi><msub><mi>p</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mtext>其余情况</mtext></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp_{x,y}=\left\{\begin{aligned}0,(x,y) 不能到达\\1,x=y=0\\dp_{i-1,j}+dp_{i,j-1}, 其余情况\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">达</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">余</span><span class="mord cjk_fallback">情</span><span class="mord cjk_fallback">况</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><p>为了避免重复计算，可以先根据马的坐标确定八个方向的点分别是哪些点，然后再枚举当前的点是不是这八个点。</p><p>当然，<strong>马所在的点也是控制点</strong>。</p><h4 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">25</span>][<span class="hljs-number">25</span>]; <span class="hljs-comment">// 存储路径条数</span><br><span class="hljs-type">bool</span> no[<span class="hljs-number">25</span>][<span class="hljs-number">25</span>]; <span class="hljs-comment">// 存储是不是控制点</span><br><span class="hljs-type">int</span> n,m,x,y;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_ctrl_pos</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">// 标记控制点</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;<br>    no[x][y]=<span class="hljs-literal">true</span>; <span class="hljs-comment">// 马所在的点一定是控制点</span><br>    <span class="hljs-built_in">write_ctrl_pos</span>(x,y); <span class="hljs-comment">// 标记其他控制点</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 原点出发，原点到原点肯定是 1 条路径</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;++j)&#123;<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 跳过原点</span><br>            <span class="hljs-keyword">if</span>(!no[i][j])&#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&lt;<span class="hljs-number">0</span>)dp[i][j]=dp[i][j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// x=0</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&lt;<span class="hljs-number">0</span>)dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">// y=0</span><br>                <span class="hljs-keyword">else</span> dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 一般情况</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; dp[n][m] &lt;&lt; endl; <span class="hljs-comment">// 直接输出最后一条的路径</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_ctrl_pos</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>&#125;&#125;; <span class="hljs-comment">// 马能控制到的点的各个方向</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;++i)&#123;<br>        <span class="hljs-type">int</span> tx=x+dir[i][<span class="hljs-number">0</span>],ty=y+dir[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(tx&gt;=<span class="hljs-number">0</span>&amp;&amp;tx&lt;=n&amp;&amp;ty&gt;=<span class="hljs-number">0</span>&amp;&amp;ty&lt;=m)<br>            no[tx][ty]=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题的动态规划的点在于，我们在求解下一个点的路径条数时， <strong>直接调用了上一个点的路径条数</strong>，这也是一个比较典型的自底向上的方法。</p><h3 id="2-数字三角形"><a href="#2-数字三角形" class="headerlink" title="2. 数字三角形"></a>2. <a href="https://www.lanqiao.cn/problems/505/learning/">数字三角形</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p><img src="/2024/02/29/dp-cpp/eg2-sample-triangle.png" alt="图片描述"></p><p>上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。</p><p>路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右边的那个数。此外，走完整个路径后，向左下走的次数与向右下走的次数相差不能超过 1。</p><p>输入的第一行包含一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (1≤N≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，表示三角形的行数。</p><p>下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。<br>输出描述</p><p>输出一个整数，表示答案。</p><h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">27<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目要求走到最后的时候，向左走和向右走的次数的差不超过 1。</p><p>也就是说：</p><ol><li><p>如果走了<strong>偶数次</strong>，那么向左走和向右走的次数<strong>相等</strong>。如果最后走了偶数次，则这个三角形必然是<strong>奇数行</strong>，那么最后一行的数字个数也是<strong>奇数</strong>，最终一定落到<strong>最后一行中间的那个数</strong>。</p></li><li><p>如果走了<strong>奇数次</strong>，那么向左走和向右走的次数<strong>一定差 1</strong>。如果最后走了奇数次，则这个三角形必然是<strong>偶数行</strong>，那么最后一行的数字个数也是<strong>偶数</strong>。最终回落到<strong>最后一行中间的两个数</strong>，向左走多一点则落在靠左的数，向右走多一点则落在靠右的数。</p></li></ol><p>如果一个三角形有 n 行，对于 第 i 行第 j 个数的路径和的最大值，应该是<strong>上一行两个数的路径和的最大值，分别走到这一个数（路径和 +1）的路径和的最大值</strong>。由于我们只求最后一行中间的数的路径和，也就是说，我们可以得到：</p><ol><li>n 为奇数时，这个路径和位于 n 行第 <code>(n+1)/2</code> 的位置。</li><li>n 为偶数时，这个路径和，是 n 行第 <code>n/2</code> 的位置和 <code>(n+2)/2</code> 的位置的最大值。</li></ol><p>由于 C++ 中，对于 int 类型的 <code>/</code> 是<strong>整除</strong>，当 n 为奇数时，<code>(n+2)/2</code> 和 <code>(n+1)/2</code> 的计算结果是一样的；n 为偶数时，<code>(n+1)/2</code> 的计算结果和 <code>n/2</code> 的计算结果是一样的。</p><p>所以我们只需要用 <code>max(c[n][(n+1)/2],c[n][(n+2)/2])</code> 即可同时涵盖奇数和偶数的情况。</p><p>这样，我们就可以<strong>逐个计算每个节点的最大路径和</strong>，然后一步一步得到最后一行的最大路径和，最后直接输出即可。</p><h3 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>],c[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>      cin&gt;&gt;a[i][j];<br>  c[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>      c[i][j]=a[i][j]+<span class="hljs-built_in">max</span>(c[i<span class="hljs-number">-1</span>][j],c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);<br>  cout&lt;&lt;<span class="hljs-built_in">max</span>(c[n][(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>],c[n][(n+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>算法竞赛</tag>
      
      <tag>动态规划</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 深度优先搜索 (DFS) 学习记录</title>
    <link href="/2024/02/28/dfs-cpp/"/>
    <url>/2024/02/28/dfs-cpp/</url>
    
    <content type="html"><![CDATA[<p>深度优先搜索是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。</p><p>要说个人理解的话，我的理解大概就是这样：</p><blockquote><p>有一个人去某景区旅游，他现在在景区入口，景区里的一些路，有的能通到出口，有的不能。</p><p>这个人呢很倔强，他要一条一条去走，不走到路的尽头绝不回头。</p><p>他从第一条路走下去，走到头发现没路了，再回头到上一个分叉点，记下来这个分叉走过了；然后走另一个分叉，全部分叉走完了，再回到分叉点，再往回退一个分叉，记下来这个大分叉走过了没有路，然后走下一个分叉……</p></blockquote><p>如果把这样一个景区抽象为一个图，那么也就是说，深度优先的搜索就是<strong>每次都尝试向更深的节点走</strong>。</p><p>DFS 搜索的实现方式一般是<strong>递归</strong>。也就是递归调用自身。在每次 DFS 遍历中都会对访问过的点<strong>打上标记</strong>，在遍历图的时候<strong>跳过已标记的点</strong>，以确保每个点<strong>只访问一次</strong>。</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><table><thead><tr><th align="center">时间复杂度</th><th align="center">空间复杂度</th></tr></thead></table><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> | <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="寻找路线（走迷宫）"><a href="#寻找路线（走迷宫）" class="headerlink" title="寻找路线（走迷宫）"></a>寻找路线（走迷宫）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-comment">// 设定这个位置已经访问</span><br>    visited[r][c]=<span class="hljs-literal">true</span>; <br><br>    <span class="hljs-comment">// 存储遍历时行走的参数，这样循环遍历的时候方便调用</span><br>    <span class="hljs-comment">// dr 为横着走, dc 为竖着走</span><br>    <span class="hljs-comment">// 顺序分别为：左 右 上 下</span><br>    <span class="hljs-type">int</span> dr[]=&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dc[]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-comment">/*当前位置为目标位置*/</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 遍历图，开始找路</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;d&lt;<span class="hljs-number">4</span>;++d)&#123;<br>        <span class="hljs-type">int</span> tr=r+dr[d]; <span class="hljs-comment">// 横向</span><br>        <span class="hljs-type">int</span> tc=c+dc[d]; <span class="hljs-comment">// 竖向</span><br><br>        <span class="hljs-comment">// 如果满足特定条件我就继续找，什么时候找到了 (DFS 返回 True) 就直接结束，这里不回溯</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inMap</span>(tr,tc)&amp;&amp;<span class="hljs-comment">/*满足特定条件*/</span>*&amp;&amp;!visited[tr][tc])<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">DFS</span>(tr,tc))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 没找到</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inMap</span><span class="hljs-params">(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> r&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;c&gt;=<span class="hljs-number">0</span>&amp;&amp;c&lt;m;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码调用 DFS 时，传入起点坐标，返回 <code>true</code> 则找到，<code>false</code> 则没找到。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="深さ優先探索"><a href="#深さ優先探索" class="headerlink" title="深さ優先探索"></a><a href="https://www.luogu.com.cn/problem/AT_dfs_a">深さ優先探索</a></h3><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> map[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br><span class="hljs-type">bool</span> visited[<span class="hljs-number">505</span>][<span class="hljs-number">505</span>];<br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inMap</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>            cin &gt;&gt; map[i][j];<br>    <br>    <span class="hljs-type">int</span> startx,starty;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>        <span class="hljs-keyword">if</span>(map[i][j]==<span class="hljs-string">&#x27;s&#x27;</span>)&#123;<br>            startx=i;<br>            starty=j;<br>        &#125;<br>    <br>    <span class="hljs-type">bool</span> res=<span class="hljs-built_in">DFS</span>(startx,starty);<br>    cout &lt;&lt; (res?<span class="hljs-string">&quot;Yes\n&quot;</span>:<span class="hljs-string">&quot;No\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    visited[r][c]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> dr[]=&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dc[]=&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-keyword">if</span>(map[r][c]==<span class="hljs-string">&#x27;g&#x27;</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>;d&lt;<span class="hljs-number">4</span>;++d)&#123;<br>        <span class="hljs-type">int</span> tr=r+dr[d];<br>        <span class="hljs-type">int</span> tc=c+dc[d];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inMap</span>(tr,tc)&amp;&amp;map[tr][tc]!=<span class="hljs-string">&#x27;#&#x27;</span>&amp;&amp;!visited[tr][tc])<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">DFS</span>(tr,tc))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inMap</span><span class="hljs-params">(<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> r&gt;=<span class="hljs-number">0</span>&amp;&amp;r&lt;n&amp;&amp;c&gt;=<span class="hljs-number">0</span>&amp;&amp;c&lt;m;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="灌水"><a href="#灌水" class="headerlink" title="灌水"></a><a href="https://www.lanqiao.cn/problems/7938/learning/">灌水</a></h3><p>AC 代码 (已经过处理)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> matrix[<span class="hljs-number">30</span>][<span class="hljs-number">40</span>];<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">40</span>; ++j)<br>            cin &gt;&gt; matrix[i][j]; <span class="hljs-comment">// 调试用</span><br><br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; count &lt;&lt; endl;<br>    <span class="hljs-comment">// cout &lt;&lt; 541 &lt;&lt; endl; 评测机要求必须直接输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= <span class="hljs-number">30</span> || y &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">40</span> || matrix[x][y] != <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">return</span>;<br>    count++;<br>    matrix[x][y] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    <span class="hljs-built_in">DFS</span>(x + <span class="hljs-number">1</span>, y);<br>    <span class="hljs-built_in">DFS</span>(x - <span class="hljs-number">1</span>, y);<br>    <span class="hljs-built_in">DFS</span>(x, y + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">DFS</span>(x, y - <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这里面没有单独存储已经遍历过的位置，是因为题目要求每走一步，就将这个地方标记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，也相当于已经标记过了。</p><h3 id="最大连通"><a href="#最大连通" class="headerlink" title="最大连通"></a><a href="https://www.lanqiao.cn/problems/2410/learning/">最大连通</a></h3><p>AC 代码（已经过处理）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> matrix[<span class="hljs-number">30</span>][<span class="hljs-number">60</span>];<br><span class="hljs-type">bool</span> visited[<span class="hljs-number">30</span>][<span class="hljs-number">60</span>];<br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>,cntmax=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;++i)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">60</span>;++j)<br>      cin &gt;&gt; matrix[i][j];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;++i)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">60</span>;++j)&#123;<br>        count=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">DFS</span>(i,j);<br>        cntmax=<span class="hljs-built_in">max</span>(count,cntmax);<br>      &#125;<br><br>  cout &lt;&lt; cntmax &lt;&lt; endl;<br>  <span class="hljs-comment">// cout &lt;&lt; 148 &lt;&lt; endl; 评测机要求必须直接输出结果</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=<span class="hljs-number">30</span>||y&lt;<span class="hljs-number">0</span>||y&gt;=<span class="hljs-number">60</span>||matrix[x][y]==<span class="hljs-string">&#x27;0&#x27;</span>||visited[x][y]==<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span>;<br>  visited[x][y]=<span class="hljs-number">1</span>;<br>  count++;<br><br>  <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)&#123;<br>    <span class="hljs-type">int</span> nextx=x+dx[i];<br>    <span class="hljs-type">int</span> nexty=y+dy[i];<br>    <span class="hljs-keyword">if</span>(nextx&gt;=<span class="hljs-number">0</span>&amp;&amp;nextx&lt;<span class="hljs-number">30</span>&amp;&amp;nexty&gt;=<span class="hljs-number">0</span>&amp;&amp;nexty&lt;<span class="hljs-number">60</span>&amp;&amp;matrix[nextx][nexty]==<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;visited[nextx][nexty]==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">DFS</span>(nextx,nexty);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>算法竞赛</tag>
      
      <tag>搜索</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红米手机 2 刷机资源 / 教程</title>
    <link href="/2024/02/04/redmi-2-flashing/"/>
    <url>/2024/02/04/redmi-2-flashing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>红米手机 2 是小米公司于 2015 年 1 月 3 日在 QQ 上正式发布的手机。</p><p>红米手机 2 屏幕采用 4.7 英寸全贴合 IPS 视网膜屏；红米手机 2 高度 134 毫米，宽度 67.2 毫米，厚度 9.4 毫米，重量 133 克。红米手机 2 有白色、深灰、明黄、浅绿、淡粉五种颜色。</p><p>红米手机 2 搭载高通骁龙 410 四核处理器，后置 800 万像素背照式相机，5 片式镜头，f&#x2F;2.2 光圈，28 毫米广角，200 万像素前置相机，支持二代智能美颜，电池容量 2200 毫安时。</p><footer><strong>百度百科</strong><cite><a href="https://baike.baidu.com/item/%E7%BA%A2%E7%B1%B3%E6%89%8B%E6%9C%BA2">baike.baidu.com/item/%E7%BA%A2%E7%B1%B3%E6%89%8B%E6%9C%BA2</a></cite></footer></blockquote><p>红米 2 是红米系列非常经典的一个机型，诞生于刷机黄金时代的它，拥有很多刷机资源，甚至还可以运行完整的 GNU&#x2F;Linux，在可玩性上也是非常高的。直到今天，仍然有大佬在给红米 2 做出了安卓 13 的适配，这对于一个 2015 年初的入门机型来说，是非常少见的。</p><h2 id="为什么选择红米-2-刷机？"><a href="#为什么选择红米-2-刷机？" class="headerlink" title="为什么选择红米 2 刷机？"></a>为什么选择红米 2 刷机？</h2><ul><li>价格便宜。截止文章发稿时，2+16GB 的红米 2 在闲鱼上只需要 50-80 元左右，1+8GB 的会更便宜，即使不小心刷坏了也不心疼。</li><li>没有 BL 锁，可以任意刷。</li><li>刷机包非常丰富，安卓从 4.4 到 13，每一个版本都有许多刷机包可供选择，甚至还有 PostmarketOS、Mobian 这样的 GNU&#x2F;Linux 发行版。</li><li>功耗低，性能够用。红米 2 的骁龙 410 处理器也算是历史上的一颗神U，刷 GNU&#x2F;Linux 性能比树莓派高，价格远低于树莓派。（有很多人选择用红米 2 作 3D 打印机的上位机）</li></ul><h2 id="适用设备"><a href="#适用设备" class="headerlink" title="适用设备"></a>适用设备</h2><p>本教程适用于以下设备，内存规格不限：</p><h3 id="wt86047"><a href="#wt86047" class="headerlink" title="wt86047"></a>wt86047</h3><table><thead><tr><th align="center">设备名称</th><th align="center">型号</th></tr></thead><tbody><tr><td align="center">2014813</td><td align="center">红米 2 移动版</td></tr><tr><td align="center">2014112</td><td align="center">红米 2 移动合约版</td></tr><tr><td align="center">2014816</td><td align="center">红米 2A 高配版</td></tr></tbody></table><h3 id="wt88047"><a href="#wt88047" class="headerlink" title="wt88047"></a>wt88047</h3><table><thead><tr><th align="center">设备名称</th><th align="center">型号</th></tr></thead><tbody><tr><td align="center">2014811</td><td align="center">红米 2 联通版</td></tr><tr><td align="center">2014812</td><td align="center">红米 2 电信版</td></tr><tr><td align="center">2014821</td><td align="center">红米 2 电信合约版</td></tr><tr><td align="center">2014817</td><td align="center">红米 2 国际版</td></tr><tr><td align="center">2014818</td><td align="center">红米 2 印度版</td></tr><tr><td align="center">2014819</td><td align="center">红米 2 巴西版</td></tr></tbody></table><p>可以在 <code>设置 - 我的设备</code> 或者 <code>关于手机</code> 页面查到设备型号。</p><div class="note note-warning">            <p>搭载骁龙 410 的红米 2A 高配版也适用本教程，但是<strong>搭载联芯的 2A (<code>lte26007</code>) 不适用</strong>。</p>          </div><h2 id="资源汇总"><a href="#资源汇总" class="headerlink" title="资源汇总"></a>资源汇总</h2><p><a href="https://www.123pan.com/s/vzWAjv-uEgV3.html">123 云盘链接</a></p><p>提取码：<code>hm02</code></p><p>安卓刷机包按版本代号整理。</p><div class="note note-danger">            <p>刷机前请<strong>备份重要数据</strong>。刷机<strong>有风险</strong>，<strong>操作需谨慎</strong>。</p>          </div><h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><h3 id="刷入-TWRP"><a href="#刷入-TWRP" class="headerlink" title="刷入 TWRP"></a>刷入 TWRP</h3><p>设备搭载的骁龙 410 处理器是 <strong>64 位</strong>的，但官方的 MIUI 系统都是 <strong>32 位</strong>的。但是第三方 ROM 中有不少 64 位的，可以运行现代 64 位应用。</p><div class="note note-info">            <p>64 位 TWRP 可以用来刷 64 位系统，也可以刷 32 位系统，但是 32 位的 TWRP 只能用来刷 32 位系统，不能用来刷 64 位系统</p>          </div><p>换句话说，刷 64 位系统必须用 64 位 TWRP。</p><h3 id="更换底包"><a href="#更换底包" class="headerlink" title="更换底包"></a>更换底包</h3><p>先根据要刷入的 ROM 的安卓版本，和自己的型号刷入对应的底包。如果是国际版，可以刷电信联通版的底包。</p><table><thead><tr><th align="center">底包</th><th align="center">可刷入的 ROM 安卓版本</th></tr></thead><tbody><tr><td align="center">4.4</td><td align="center">安卓 4.4（Kitkat）</td></tr><tr><td align="center">5.1</td><td align="center">安卓 5.1 及以上所有版本</td></tr></tbody></table><p>底包通过 TWRP 卡刷即可。</p><h3 id="刷入刷机包"><a href="#刷入刷机包" class="headerlink" title="刷入刷机包"></a>刷入刷机包</h3><p>一定先阅读资源目录内的<em>刷前说明</em>，由于每个包的刷入方式不同，请务必按照里面的说明操作！没有说明的包直接刷入即可。</p><p>有的包需要扩容，手动扩容、分区丢失修复等情况，详见<a href="#%E6%89%A9%E5%AE%B9">“扩容”一节</a>。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><div class="note note-danger">            <p>本小节未完成。我的设备不在身边，没法继续演示具体的情况。</p><p>有愿意协助的可以帮我补充或联系我协助完成，谢谢。</p>          </div><div class="note note-warning">            <p>部分无需扩容的刷机包<strong>不支持扩容后的分区</strong>，直接刷入已扩容设备<strong>可能会无法启动</strong>。</p><p>如果设备扩容后需要刷回不需扩容的包，请<strong>恢复原厂分区后</strong>再刷入。</p>          </div><p>部分包（高版本安卓系统、64 位系统）需要更大的系统分区，刷入这些包之前，我们需要进行扩容操作。</p><p>刷机资源内提供了自动扩容的包，当然有时候我们会遇到以下情况：</p><ul><li>分区丢失或者异常，导致卡米 &#x2F; 系统无法进入</li><li>手上没有 SD 卡，用不了自动扩容包</li></ul><p>这个时候我们需要使用资源内的 <code>parted</code> 工具进行手动扩容。</p><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>下载资源汇总内的 <code>parted</code>。</li><li>手机进入 TWRP，然后连接电脑。</li><li>用 <code>adb push</code> 命令将 <code>parted</code> 复制到 <code>/sbin</code> 目录下，然后执行 <code>adb shell</code>进入 Shell。</li><li>执行 <code>chmod 755 /sbin/parted</code> 已获取必要权限运行 <code>parted</code>。</li><li>然后运行 <code>parted /dev/block/mmcblk0</code>。</li></ol><h4 id="分区操作"><a href="#分区操作" class="headerlink" title="分区操作"></a>分区操作</h4><p>运行 <code>parted /dev/block/mmcblk0</code> 命令后，你能看到如下输出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">GNU Parted <span class="hljs-number">1.8</span>.<span class="hljs-number">8.1</span>.<span class="hljs-number">179</span>-aef3<br><span class="hljs-keyword">Using</span> /dev/<span class="hljs-keyword">block</span>/mmcblk0<br>Welcome <span class="hljs-keyword">to</span> GNU Parted! <span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;help&#x27;</span> <span class="hljs-keyword">to</span> view a list <span class="hljs-keyword">of</span> commands.<br>(parted)<br></code></pre></td></tr></table></figure><p>此时表明你已进入 <code>parted</code> 分区程序。</p><div class="note note-danger">            <p>接下来的操作请<strong>务必小心</strong>，因为改动分区可不是闹着玩的！</p><p>请再次确认重要数据已经备份，如果还没有，请输入 <code>q</code> 退出。</p>          </div><p>输入 <code>p</code> 查看设备分区表。2+16GB 的分区表应该如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Model</span>: MMC R1J96N (sd/mmc)<br><span class="hljs-attribute">Disk</span> /dev/block/mmcblk0: <span class="hljs-number">15</span>.<span class="hljs-number">8</span>GB<br><span class="hljs-attribute">Sector</span> size (logical/physical): <span class="hljs-number">512</span>B/<span class="hljs-number">512</span>B<br><span class="hljs-attribute">Partition</span> Table: gpt<br><br><span class="hljs-attribute">Number</span>  Start   End     Size    File system  Name      Flags<br> <span class="hljs-attribute">1</span>      <span class="hljs-number">67</span>.<span class="hljs-number">1</span>MB  <span class="hljs-number">134</span>MB   <span class="hljs-number">67</span>.<span class="hljs-number">1</span>MB  fat16        modem<br> <span class="hljs-attribute">2</span>      <span class="hljs-number">134</span>MB   <span class="hljs-number">135</span>MB   <span class="hljs-number">524</span>kB                sbl1<br> <span class="hljs-attribute">3</span>      <span class="hljs-number">135</span>MB   <span class="hljs-number">135</span>MB   <span class="hljs-number">524</span>kB                sbl1bak<br> <span class="hljs-attribute">4</span>      <span class="hljs-number">135</span>MB   <span class="hljs-number">136</span>MB   <span class="hljs-number">1049</span>kB               aboot<br> <span class="hljs-attribute">5</span>      <span class="hljs-number">136</span>MB   <span class="hljs-number">137</span>MB   <span class="hljs-number">1049</span>kB               abootbak<br> <span class="hljs-attribute">6</span>      <span class="hljs-number">137</span>MB   <span class="hljs-number">138</span>MB   <span class="hljs-number">524</span>kB                rpm<br> <span class="hljs-attribute">7</span>      <span class="hljs-number">138</span>MB   <span class="hljs-number">138</span>MB   <span class="hljs-number">524</span>kB                rpmbak<br> <span class="hljs-attribute">8</span>      <span class="hljs-number">138</span>MB   <span class="hljs-number">139</span>MB   <span class="hljs-number">524</span>kB                tz<br> <span class="hljs-attribute">9</span>      <span class="hljs-number">139</span>MB   <span class="hljs-number">139</span>MB   <span class="hljs-number">524</span>kB                tzbak<br><span class="hljs-attribute">10</span>      <span class="hljs-number">139</span>MB   <span class="hljs-number">140</span>MB   <span class="hljs-number">524</span>kB                hyp<br><span class="hljs-attribute">11</span>      <span class="hljs-number">140</span>MB   <span class="hljs-number">141</span>MB   <span class="hljs-number">524</span>kB                hypbak<br><span class="hljs-attribute">12</span>      <span class="hljs-number">141</span>MB   <span class="hljs-number">142</span>MB   <span class="hljs-number">1049</span>kB               pad<br><span class="hljs-attribute">13</span>      <span class="hljs-number">142</span>MB   <span class="hljs-number">143</span>MB   <span class="hljs-number">1573</span>kB               modemst1<br><span class="hljs-attribute">14</span>      <span class="hljs-number">143</span>MB   <span class="hljs-number">145</span>MB   <span class="hljs-number">1573</span>kB               modemst2<br><span class="hljs-attribute">15</span>      <span class="hljs-number">145</span>MB   <span class="hljs-number">146</span>MB   <span class="hljs-number">1049</span>kB               misc<br><span class="hljs-attribute">16</span>      <span class="hljs-number">146</span>MB   <span class="hljs-number">146</span>MB   <span class="hljs-number">1024</span>B                fsc<br><span class="hljs-attribute">17</span>      <span class="hljs-number">146</span>MB   <span class="hljs-number">146</span>MB   <span class="hljs-number">8192</span>B                ssd<br><span class="hljs-attribute">18</span>      <span class="hljs-number">146</span>MB   <span class="hljs-number">156</span>MB   <span class="hljs-number">10</span>.<span class="hljs-number">5</span>MB               splash<br><span class="hljs-attribute">19</span>      <span class="hljs-number">201</span>MB   <span class="hljs-number">201</span>MB   <span class="hljs-number">32</span>.<span class="hljs-number">8</span>kB               DDR<br><span class="hljs-attribute">20</span>      <span class="hljs-number">201</span>MB   <span class="hljs-number">203</span>MB   <span class="hljs-number">1573</span>kB               fsg<br><span class="hljs-attribute">21</span>      <span class="hljs-number">203</span>MB   <span class="hljs-number">203</span>MB   <span class="hljs-number">16</span>.<span class="hljs-number">4</span>kB               sec<br><span class="hljs-attribute">22</span>      <span class="hljs-number">203</span>MB   <span class="hljs-number">237</span>MB   <span class="hljs-number">33</span>.<span class="hljs-number">6</span>MB               boot<br><span class="hljs-attribute">23</span>      <span class="hljs-number">237</span>MB   <span class="hljs-number">1757</span>MB  <span class="hljs-number">1520</span>MB  ext4         system<br><span class="hljs-attribute">24</span>      <span class="hljs-number">1757</span>MB  <span class="hljs-number">1808</span>MB  <span class="hljs-number">51</span>.<span class="hljs-number">2</span>MB  ext4         cache<br><span class="hljs-attribute">25</span>      <span class="hljs-number">1808</span>MB  <span class="hljs-number">1841</span>MB  <span class="hljs-number">33</span>.<span class="hljs-number">6</span>MB  ext4         persist<br><span class="hljs-attribute">26</span>      <span class="hljs-number">1841</span>MB  <span class="hljs-number">1875</span>MB  <span class="hljs-number">33</span>.<span class="hljs-number">6</span>MB               recovery<br><span class="hljs-attribute">27</span>      <span class="hljs-number">1875</span>MB  <span class="hljs-number">1875</span>MB  <span class="hljs-number">524</span>kB                keystore<br><span class="hljs-attribute">28</span>      <span class="hljs-number">1875</span>MB  <span class="hljs-number">1875</span>MB  <span class="hljs-number">32</span>.<span class="hljs-number">8</span>kB               config<br><span class="hljs-attribute">29</span>      <span class="hljs-number">1875</span>MB  <span class="hljs-number">1978</span>MB  <span class="hljs-number">102</span>MB   ext4         oem<br><span class="hljs-attribute">30</span>      <span class="hljs-number">1978</span>MB  <span class="hljs-number">15</span>.<span class="hljs-number">8</span>GB  <span class="hljs-number">13</span>.<span class="hljs-number">8</span>GB  ext4         userdata<br></code></pre></td></tr></table></figure><pre><code class="hljs">我们需要调整的分区是编号 `23` 的 `system` 分区。因此我们需要动 `23` - `30` 号分区。</code></pre><ol><li><p>删除旧分区，依次执行以下命令：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rm</span> <span class="hljs-number">23</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">25</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">26</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">27</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">28</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">29</span><br><span class="hljs-attribute">rm</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p> 执行完可以输入 <code>p</code> 查看分区是否已修改。此时编号应该只到 <code>22</code>，下面应该是未分配的。如果中间有确认就输入 <code>y</code> 确认。</p></li><li><p>创建分区。</p><p> 对于 2+16GB 的设备，依次输入以下命令：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">236503040</span>B <span class="hljs-number">1756503551</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">23</span> system<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1756503552</span>B <span class="hljs-number">1807703551</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">24</span> cache<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1807703552</span>B <span class="hljs-number">1841257983</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">25</span> persist<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1841257984</span>B <span class="hljs-number">1874812415</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">26</span> recovery<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1874812416</span>B <span class="hljs-number">1875336703</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">27</span> keystore<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1875336704</span>B <span class="hljs-number">1875369471</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">28</span> config<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1875369472</span>B <span class="hljs-number">1977769471</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">29</span> oem<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1977769472</span>B <span class="hljs-number">15757983231</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">30</span> userdata<br></code></pre></td></tr></table></figure><p> 对于 1+8GB 的设备，输入以下命令：</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">236503040</span>B <span class="hljs-number">1756503551</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">23</span> system<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1756503552</span>B <span class="hljs-number">1807703551</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">24</span> cache<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1807703552</span>B <span class="hljs-number">1841257983</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">25</span> persist<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1841257984</span>B <span class="hljs-number">1874812415</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">26</span> recovery<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1874812416</span>B <span class="hljs-number">1875336703</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">27</span> keystore<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1875336704</span>B <span class="hljs-number">1875369471</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">28</span> config<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1875369472</span>B <span class="hljs-number">1977769471</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">29</span> oem<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1977769472</span>B <span class="hljs-number">7818165759</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">30</span> userdata<br></code></pre></td></tr></table></figure><p> 有时候可能会弹出询问，按 <code>y</code> 确认即可。</p></li><li><p>输入 <code>quit</code> 退出 <code>parted</code>。</p></li><li><p>格式化分区，依次输入以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mke2fs -t ext4 -b 4096 /dev/block/mmcblk0p23<br>mke2fs -t ext4 -b 4096 /dev/block/mmcblk0p24<br>mke2fs -t ext4 -b 4096 /dev/block/mmcblk0p29<br>mke2fs -t ext4 -b 4096 /dev/block/mmcblk0p30<br></code></pre></td></tr></table></figure></li><li><p>关联文件系统，依次输入以下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p23 system<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p24 cache<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p25 persist<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p26 recovery<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p27 keystore<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p28 config<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p29 oem<br><span class="hljs-built_in">ln</span> -sf /dev/block/mmcblk0p30 userdata<br></code></pre></td></tr></table></figure></li><li><p>在 TWRP 中选择 <code>重启</code> - <code>重启至 Recovery</code>。此时你会发现 <code>system</code> 分区扩容到了 2GB。这个大小对于大多数刷机包都是完全足够的。此时你可以删掉 <code>parted</code>，也可以保留。如果要删除 <code>parted</code>，执行 <code>rm /sbin/parted</code>。</p></li></ol><h3 id="恢复原厂分区"><a href="#恢复原厂分区" class="headerlink" title="恢复原厂分区"></a>恢复原厂分区</h3><p>恢复原厂分区的操作除了<strong>第 2 步创建分区</strong>不一样外，其他的步骤<strong>一模一样</strong>。</p><p>对于 2+16GB 的设备，第 2 步应该依次输入以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">236503040</span>B <span class="hljs-number">1310244863</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">23</span> system<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1310244864</span>B <span class="hljs-number">1645789183</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">24</span> cache<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1645789184</span>B <span class="hljs-number">1679343615</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">25</span> persist<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1679343616</span>B <span class="hljs-number">1712898047</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">26</span> recovery<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1744830464</span>B <span class="hljs-number">1745354751</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">27</span> keystore<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1745354752</span>B <span class="hljs-number">1745387519</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">28</span> config<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1745387520</span>B <span class="hljs-number">1812496383</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">29</span> oem<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1879048192</span>B <span class="hljs-number">15757983231</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">30</span> userdata<br></code></pre></td></tr></table></figure><p>对于 1+8GB 的设备，第 2 步应该依次输入以下命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">236503040</span>B <span class="hljs-number">1310244863</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">23</span> system<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1310244864</span>B <span class="hljs-number">1645789183</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">24</span> cache<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1645789184</span>B <span class="hljs-number">1679343615</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">25</span> persist<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1679343616</span>B <span class="hljs-number">1712898047</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">26</span> recovery<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1744830464</span>B <span class="hljs-number">1745354751</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">27</span> keystore<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1745354752</span>B <span class="hljs-number">1745387519</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">28</span> config<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1745387520</span>B <span class="hljs-number">1812496383</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">29</span> oem<br><span class="hljs-attribute">mkpart</span> primary <span class="hljs-number">1879048192</span>B <span class="hljs-number">7818165759</span>B<br><span class="hljs-attribute">name</span> <span class="hljs-number">30</span> userdata<br></code></pre></td></tr></table></figure><p>其他步骤照着<a href="#%E6%89%A9%E5%AE%B9">扩容分区步骤</a>去做就可以了。</p><h2 id="GNU-Linux"><a href="#GNU-Linux" class="headerlink" title="GNU&#x2F;Linux"></a>GNU&#x2F;Linux</h2><div class="note note-danger">            <p>Linux 包<strong>不适合日常使用</strong>！</p><p>运行 GNU&#x2F;Linux 系统时，充电的时候需格外注意。最好在 TWRP Recovery 下为设备充电。<strong>不要让设备在无人看管的情况下充电！</strong> 充满后即使拔下，避免挂着一直充。</p>          </div><div class="note note-info">            <p>目前已知问题：</p><ul><li>相机无法使用</li><li>偶发性的卡死和闪屏</li><li>部分型号屏幕可能会出现显示异常</li></ul>          </div><div class="note note-warning">            <p>本包只支持安卓 5.1 的 Bootloader。如果是标配官方 4.4 或者其他第三方 ROM 刷入，请先<a href="#%E6%9B%B4%E6%8D%A2%E5%BA%95%E5%8C%85">刷入 MIUI 5.1 底包</a> （BL 更换）。</p>          </div><p>方法如下：</p><ol><li><p>在 <code>fastboot</code> 下刷入 <code>lk2nd</code>：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fastboot flash boot lk2nd-msm8916.img<br></code></pre></td></tr></table></figure></li><li><p>执行 <code>fastboot reboot</code> 重启</p></li><li><p>开机后进入 <code>lk2nd</code> 的主界面，不要动，手机重新连接电脑，直接执行：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 填写实际下载到的文件</span><br>fastboot flash userdata 202******-****-postmarketOS-v**.**-phosh-18-xiaomi-wt88047.img<br></code></pre></td></tr></table></figure></li><li><p>完成后执行此命令重置 <code>system</code> 分区：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fastboot erase system    <br></code></pre></td></tr></table></figure></li><li><p>完成后重启。执行：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fastboot reboot<br></code></pre></td></tr></table></figure></li><li><p>重启后进入 <code>lk2nd</code> 的主界面，按音量键调整最上面显示 <code>START</code>，然后按电源键进入系统</p></li></ol><p>开机后 mi 标逐渐变红 &#x2F; 变花是正常现象，此为加载显示驱动，耐心等待即可。</p><p>默认用户名：<code>user</code></p><p>默认解锁密码：<code>147147</code></p><p>默认用户 <code>user</code> 的密码：<code>147147</code></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>安卓玩机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷机</tag>
      
      <tag>红米2</tag>
      
      <tag>玩机</tag>
      
      <tag>红米手机</tag>
      
      <tag>小米</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不重装系统，直接从 Manjaro 切换到 Arch Linux</title>
    <link href="/2024/02/03/migrating-from-manjaro-to-arch/"/>
    <url>/2024/02/03/migrating-from-manjaro-to-arch/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>直接切换存在一定的“滚挂”风险，操作前建议做好重装系统的准备。</p>          </div><div class="note note-danger">            <p>虽然本教程的方法也可以直接从 Arch Linux 切换到 Manjaro，但我建议<strong>不要这样做！</strong> Arch Linux 的软件包普遍比 Manjaro 新，从 Arch 切换到 Manjaro 很可能会因为版本问题导致依赖冲突，增加“滚挂”风险！</p>          </div><p><del>众所周知</del>，Manjaro 是基于 Arch Linux 的一个发行版，但是 Manjaro 的大部分软件包的版本要低于 Arch Linux，使得 Manjaro 在获得近似 Arch 的优秀体验的同时，也保持良好的稳定性。</p><p>不过有时候总想尝试一下 Arch，重装系统又很麻烦，考虑到 Manjaro 和 Arch 的东西很接近 <del>（不像 Ubuntu 瞎改 Debian 还加屎山进去）</del>，直接迁移是一个比较方便快捷的选择。</p><p>演示环境为一个全新安装的 Manjaro + KDE 虚拟机。</p><p><img src="/2024/02/03/migrating-from-manjaro-to-arch/manjaro-initial.png" alt="Manjaro 初始环境"></p><div class="note note-danger">            <p>操作结束前，<strong>不要重启系统</strong>！</p>          </div><h2 id="更改-pacman-设置"><a href="#更改-pacman-设置" class="headerlink" title="更改 pacman 设置"></a>更改 <code>pacman</code> 设置</h2><p>编辑 <code>/etc/pacman.conf</code>，去除所有与 <code>manjaro</code> 相关的内容。</p><p>要改动的地方大致有以下部分，其他地方最好也检查一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 18 行<br>HoldPkg      = pacman glibc<br><br># 20 行 SyncFirst 注释掉<br># SyncFirst    = archlinux-keyring<br></code></pre></td></tr></table></figure><h2 id="更换-Arch-Linux-镜像源"><a href="#更换-Arch-Linux-镜像源" class="headerlink" title="更换 Arch Linux 镜像源"></a>更换 Arch Linux 镜像源</h2><p>编辑 <code>/etc/pacman.d/mirrorlist</code>，将 Manjaro 镜像源删除，替换为 Arch Linux 对应的镜像源地址。我这里选择了科大和上交的源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch<br>Server = https://mirror.sjtu.edu.cn/archlinux/$repo/os/$arch<br></code></pre></td></tr></table></figure><p>然后同步数据库，但需要注意，这个时候<strong>不要更新软件</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Syy<br></code></pre></td></tr></table></figure><h2 id="微调软件配置"><a href="#微调软件配置" class="headerlink" title="微调软件配置"></a>微调软件配置</h2><p>虽然 Manjaro 基于 Arch，但在一些关键软件包上还是有区别的，针对这些软件包我们全部需要调整。</p><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p>Manjaro 和 Arch Linux 的 Bash 封装不同，Manjaro 将 Bash 本身与 bash 的配置文件 <code>bashrc</code> 封装成了 <code>bash</code> 和 <code>bashrc-manjaro</code> 两个软件包，而 Arch 则封装为一个包 <code>bash</code> 。并且，Manjaro 的 <code>bash</code> 包依赖于 <code>bashrc-manjaro</code>，所以需要对现有 Manjaro 文件系统进行微调。</p><p>移除旧的 <code>bashrc</code> 文件，然后重新安装 <code>bash</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mv</span> /etc/bash.bashrc /etc/bash.bashrc.old<br>sudo <span class="hljs-built_in">mv</span> /etc/skel/.bashrc /etc/skel/.bashrc.old<br>sudo pacman -Sy bash<br></code></pre></td></tr></table></figure><p>安装成功后，卸载 <code>bashrc-manjaro</code> 包。</p><div class="note note-warning">            <p>卸载 Manjaro 相关包时，避免使用 <code>-Rs</code>、<code>-Rsn</code>、<code>-Rsc</code>、<code>-Rsnc</code> 等带有 <code>s</code> 和 <code>c</code> 的参数，防止破坏系统组件。</p>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Rn bashrc-manjaro<br></code></pre></td></tr></table></figure><h3 id="Linux-内核"><a href="#Linux-内核" class="headerlink" title="Linux 内核"></a>Linux 内核</h3><p>Linux 内核，Arch 官方始终只提供最新版本 <code>linux</code> 和长期支持版本 <code>linux-lts</code>，但是 Manjaro 提供了多个不同的版本 <code>linux-版本号</code>。为了保险，我们先安装 Arch Linux 的 <code>linux</code> 内核，再卸载 Manjaro 的内核。</p><p>先查找 Manjaro 内核的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Qsq linux | grep linux<br></code></pre></td></tr></table></figure><p>然后找到 <code>linux**</code> 这样一个包，比如 <code>linux66</code>、<code>linux515</code> 之类的。</p><p>这个包后面的数字，就是版本号。记下包名，卸载 Manjaro 的 Linux 内核的时候，要全部卸载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S linux linux-headers<br>sudo pacman -Rn linux66 <span class="hljs-comment"># 填写刚刚记下的包名</span><br>sudo pacman -S linux-firmware<br></code></pre></td></tr></table></figure><p>如果有对应的 <code>headers</code> 也要全部卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -Rn linux66-headers<br><span class="hljs-comment"># 如果有就卸载，没有就跳过</span><br></code></pre></td></tr></table></figure><h3 id="pacman-mirrors"><a href="#pacman-mirrors" class="headerlink" title="pacman-mirrors"></a><code>pacman-mirrors</code></h3><p><code>pacman-mirrors</code> 是 Manjaro 自己的镜像配置文件，Arch Linux 只使用 <code>pacman-mirrorlist</code>。由于 <code>pacman-mirrors</code> 和 Manjaro 的 Pacman 绑定，所以这一步我们需要先安装 Arch Linux 的 Pacman，然后通过破坏依赖的方式移除 <code>pacman-mirrors</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S pacman<br>sudo pacman -Rdd pacman-mirrors libpamac python-manjaro-sdk<br>sudo pacman -Rn $(pacman -Qsq pamac)<br></code></pre></td></tr></table></figure><h3 id="Manjaro-专属软件"><a href="#Manjaro-专属软件" class="headerlink" title="Manjaro 专属软件"></a>Manjaro 专属软件</h3><p>Manjaro 添加了自己专属的一些软件，我们也全部卸载，防止与 Arch Linux 冲突。</p><p>由于部分软件与系统组件深度绑定，为防止破坏系统组件，我们先安装部分 Arch Linux 的系统组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># base 依赖一个 manjaro 软件包，先换成 Arch 的</span><br>sudo pacman -S base<br><br><span class="hljs-comment"># -Qmq 参数用于查找不在软件源里的已安装的包</span><br>sudo pacman -Rn $(pacman -Qmq | grep manjaro)<br>sudo pacman -Rn $(pacman -Qmq | grep mhwd)<br>sudo pacman -Rn web-installer-url-handler<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>切记<strong>不要使用 <code>-Qsq</code> 代替 <code>-Qmq</code>！</strong></p><p><code>-Qsq</code> 的结果包含 <code>filesystem</code>，这个包是系统必备的，待会重新安装 Arch 软件包的时候会<strong>自动替换为 Arch 版本</strong>。这个包能被搜到是因为描述中包含 <code>Manjaro</code>，而它<strong>不是 Manjaro 独有的</strong>！</p>          </div><p><code>mhwd</code> 是 Manjaro 检测硬件并自动安装驱动的一个库，<del>既然你都用 Arch 了，难道还不能自己装驱动吗？</del></p><p>系统中可能还有 Manjaro 软件的残留，但我不建议现在一个一个查找删除，而是等到 Arch 软件包安装好之后再按需删除。</p><h2 id="安装-Arch-Linux-软件包"><a href="#安装-Arch-Linux-软件包" class="headerlink" title="安装 Arch Linux 软件包"></a>安装 Arch Linux 软件包</h2><p>我们先将系统中 Manjaro 的软件包替换为对应的 Arch Linux 软件包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清除以前下载的 Manjaro 的软件包</span><br>sudo pacman -Scc<br><span class="hljs-comment"># 重新安装所有已安装的库内软件包</span><br>sudo pacman -Syu $(pacman -Qnq)<br></code></pre></td></tr></table></figure><h2 id="修改-GRUB-主题"><a href="#修改-GRUB-主题" class="headerlink" title="修改 GRUB 主题"></a>修改 GRUB 主题</h2><p>Manjaro 默认的 GRUB 使用的是定制主题，我们已经删掉了，对应的配置也需要移除。</p><p>编辑 <code>/etc/default/grub</code>，修改为其他主题，或者注释掉使用默认界面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 搜索 THEME 即可，一般在 47 行上下<br># GRUB_THEME=&quot;/usr/share/grub/themes/manjaro/theme.txt&quot;<br></code></pre></td></tr></table></figure><p>我没有使用主题，直接注释掉了。</p><h2 id="Fcitx-中文输入法"><a href="#Fcitx-中文输入法" class="headerlink" title="Fcitx 中文输入法"></a>Fcitx 中文输入法</h2><p>Manjaro 通过依赖的方式，在安装 Fcitx5 的时候向 <code>/etc/xdg</code> 添加 <code>fcitx5</code> 文件夹以及配置文件，自动启用了 <code>Fcitx5</code> 在软件中的输入功能（软件包<code>manjaro-asian-input-support-fcitx5</code>），因此，Manjaro 安装 <code>Fcitx5</code> 后开箱即用，不需要配置。</p><p>但是 Arch Linux 软件源没有这一软件包，应当手动对 Fcitx5 进行配置。</p><p>编辑 <code>/etc/environment</code>，加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs conf">GTK_IM_MODULE=fcitx<br>QT_IM_MODULE=fcitx<br>XMODIFIERS=@im=fcitx<br>INPUT_METHOD=fcitx<br>SDL_IM_MODULE=fcitx<br>GLFW_IM_MODULE=ibus<br></code></pre></td></tr></table></figure><p>注意 <code>GLFW_IM_MODULE=ibus</code> 的 <code>ibus</code> 不能修改为其他的（兼容性问题）。然后保存。</p><h2 id="Zsh"><a href="#Zsh" class="headerlink" title="Zsh"></a>Zsh</h2><p>Manjaro 默认使用 Zsh 并添加了很多自己的配置，这些配置被打包成以 <code>manjaro</code> 开头的包，由于我们已经删掉了，因此需要重新配置。</p><p>当然不配置也能用，只不过没有原来 Manjaro 的那些“特色功能”了。</p><p><a href="#%E5%AE%89%E8%A3%85%E5%90%8E%E6%81%A2%E5%A4%8Dzsh">配置工作</a>我们待切换完成后再讲。</p><h2 id="重构-GRUB-启动菜单"><a href="#重构-GRUB-启动菜单" class="headerlink" title="重构 GRUB 启动菜单"></a>重构 GRUB 启动菜单</h2><p>由于我们重新安装了新内核，我们需要同步重构 GRUB 的配置文件 <code>grub.cfg</code>，以确保顺利引导。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>重新启动电脑，你会发现原来 Manjaro 的主题和壁纸都变成默认的了。恭喜你，你已经成功切换到 Arch Linux 系统！</p><p>确认系统工作正常之后，就可以自行清理不需要的软件包或者 Manjaro 残留了。</p><p><img src="/2024/02/03/migrating-from-manjaro-to-arch/arch-finish.png" alt="全部完成后"></p><p>如果不需要配置 Manjaro 原来的 Zsh，就可以结束了。如果需要恢复 Manjaro 原来的 Zsh 功能，请继续往下看。</p><h2 id="Zsh-配置"><a href="#Zsh-配置" class="headerlink" title="Zsh 配置"></a>Zsh 配置</h2><p>为什么把 Zsh 配置放最后讲呢，一个是比较复杂，另一个是确保系统基本组件正常运转后，再去做这些锦上添花的工作比较保险。</p><p>Manjaro 的 Zsh 的一些快捷功能是由以下软件包实现的，它们不属于 Manjaro 本身。</p><table><thead><tr><th align="center">软件包</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center"><code>oh-my-zsh</code></td><td align="center">Zsh 高效配置框架</td></tr><tr><td align="center"><code>oh-my-zsh-powerline-theme-git</code></td><td align="center">Powerline 主题</td></tr><tr><td align="center"><code>zsh-syntax-highlighting</code></td><td align="center">语法高亮</td></tr><tr><td align="center"><code>zsh-autosuggestions</code></td><td align="center">自动补全</td></tr></tbody></table><p>把这些软件包安装之后重新配置，即可使用相似功能。<del>（可我还是喜欢 Manjaro 绿油油的主题）</del></p><h3 id="配置-Arch-Linux-CN-源"><a href="#配置-Arch-Linux-CN-源" class="headerlink" title="配置 Arch Linux CN 源"></a>配置 Arch Linux CN 源</h3><p>虽说这些安装包都可以从 AUR 上获取，但是 Arch Linux CN 源为我们提供了已经打包好的软件包，可以通过 Pacman 直接拉取，快捷高效。</p><p>编辑 <code>/etc/pacman.conf</code>，在文件末尾添加 Arch Linux CN 源。我这里选择的是科大镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs conf">[archlinuxcn]<br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch<br></code></pre></td></tr></table></figure><p>然后安装软件源 Keyring：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S archlinuxcn-keyring<br></code></pre></td></tr></table></figure><div class="note note-info">            <p>如果遇到错误，可以参考<a href="https://www.archlinuxcn.org/archlinuxcn-keyring-manually-trust-farseerfc-key/">此篇文章</a>。</p>          </div><h3 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h3><p>执行以下命令安装相关软件包。相比于 Powerline 主题，我更喜欢 Powerlevel 10K 这个主题，风格几乎一模一样但性能更好。所以我选择安装 Powerlevel 10K 主题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S zsh-theme-powerlevel10k oh-my-zsh-git zsh-syntax-highlighting zsh-autosuggestions<br></code></pre></td></tr></table></figure><h3 id="配置-zshrc"><a href="#配置-zshrc" class="headerlink" title="配置 .zshrc"></a>配置 <code>.zshrc</code></h3><p>复制新的 <code>.zshrc</code> 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> ~/.zshrc ~/.zshrc.old    <span class="hljs-comment"># 备份原来的文件</span><br><span class="hljs-built_in">cp</span> /usr/share/oh-my-zsh/zshrc ~/.zshrc<br></code></pre></td></tr></table></figure><p>然后编辑 <code>~/.zshrc</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ZSH_THEME 这一行修改如下</span><br>ZSH_THEME=<span class="hljs-string">&quot;powerlevel10k/powerlevel10k&quot;</span><br><br><span class="hljs-comment"># 这一行去掉注释</span><br>ENABLE_CORRECTION=<span class="hljs-string">&quot;true&quot;</span><br><br><span class="hljs-comment"># plugins 这一行，添加以下两个插件</span><br>plugins=(zsh-syntax-highlighting zsh-autosuggestions)<br><span class="hljs-comment"># 其他插件如果有也保留</span><br></code></pre></td></tr></table></figure><p>然后将插件链接到正确的目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ln</span> -s /usr/share/zsh/plugins/zsh-syntax-highlighting /usr/share/oh-my-zsh/custom/plugins/<br><br>sudo <span class="hljs-built_in">ln</span> -s /usr/share/zsh/plugins/zsh-autosuggestions /usr/share/oh-my-zsh/custom/plugins/<br><br>sudo <span class="hljs-built_in">ln</span> -s /usr/share/zsh-theme-powerlevel10k /usr/share/oh-my-zsh/themes<br><br>sudo <span class="hljs-built_in">mv</span> /usr/share/oh-my-zsh/themes/zsh-theme-powerlevel10k /usr/share/oh-my-zsh/themes/powerlevel10k<br></code></pre></td></tr></table></figure><p>然后执行 <code>source ~/.zshrc</code> 并根据向导配置即可。</p><p><img src="/2024/02/03/migrating-from-manjaro-to-arch/zsh-conf-neofetch.png" alt="配置完成后的样式，还是很好看的，自动补全和语法高亮也生效了"></p><p>完成后可以将默认 Shell 切换到 Zsh。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>Root 用户的 Shell <strong>应当设定为 Bash</strong> 而不是 Zsh 等其他 Shell。我也不建议更改 Root 用户的 Shell。</p>          </div><p>就这样。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>GNU/Linux</tag>
      
      <tag>Manjaro</tag>
      
      <tag>Arch Linux</tag>
      
      <tag>系统切换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 高精度运算 学习记录</title>
    <link href="/2024/02/02/bignum-cpp/"/>
    <url>/2024/02/02/bignum-cpp/</url>
    
    <content type="html"><![CDATA[<p><del>咱们都知道，</del><code>int</code> 的范围大约是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>±</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">\pm10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">±</span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>，<code>double</code> 的范围大约是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>18</mn></msup></mrow><annotation encoding="application/x-tex">10^{18}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>，那么比这还大的数，我连存储都是个难题，该怎么去进行计算呢？</p><p>这个时候，当常规的变量无法存储这么大的数字时，我们就得用点<del>歪门邪道</del>了。</p><h2 id="用-Python-直接算"><a href="#用-Python-直接算" class="headerlink" title="用 Python 直接算"></a><del>用 Python 直接算</del></h2><p>好吧， Python 确实可以直接算……</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p>一个有着很多位的数，我们可以通过<strong>数组</strong>或者 <code>vector</code> 存储每个位上的数字。</p><p>读入的时候，存储的字符串中，高位在前面，低位在后面。但是习惯上，下标最小的位置存放的是数字的<strong>最低位</strong>（<strong>反转存储</strong>），这样的话，当最高位前面还是在添加数字的时候，方便直接在数组后面加，而不是正常存储顺序那样还得把整个字符串往后移动。</p><p>我的反转数字的解决方案如下，最后我将数字存储到一个数组中，也方便后续操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span>&#123;<br>    string as;<br>    cin &gt;&gt; as;<br>    <span class="hljs-type">int</span> lena=<span class="hljs-built_in">strlen</span>(as);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lena;++i)<br>        a[i]=as[lena-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p>对于四则运算，我采取的方法是<strong>模拟竖式</strong>。</p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>按照竖式的逻辑，从最小位开始逐位相加，需要进位的时候，在高位加一个 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> res[])</span></span>&#123;<br>    <span class="hljs-comment">// 假设 a 和 b 均为反转存储后的数字，res 用来存放结果且已经设置为全 0</span><br>    <span class="hljs-comment">// LEN 为所有数组的最大长度</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;LEN;++i)&#123;<br>        res[i]+=a[i]+b[i];<br>        <span class="hljs-keyword">if</span>(res[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>            ++res[i+<span class="hljs-number">1</span>];<br>            res[i]%=<span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>减法也一样，需要借位的时候高位减去 $1$。</p><p>不过有时候会遇到结果为负这个问题，我的处理方法是先判断大小，如果被减数小于减数就反过来调用，结果再添加负号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> res[])</span></span>&#123;<br>    <span class="hljs-comment">// 假设已经判断好 a 大于 b</span><br>    res[i]+=a[i]-b[i];<br>    <span class="hljs-keyword">if</span>(res[i])&lt;<span class="hljs-number">0</span>&#123;<br>        c[i+<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<br>        res[i]+=<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>乘法也一样，直接用竖式计算的思路就可以了。不过我打算最后一起处理进位而不是每次都处理，其实这个地方也无所谓……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> res[])</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;LEN<span class="hljs-number">-1</span>;++i)&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span><br><span class="hljs-comment">    第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i++j)<br>      res[i]+=a[j]*b[i-j];<br><br>    <span class="hljs-keyword">if</span>(res[i]&gt;=<span class="hljs-number">10</span>)&#123;<br>      res[i+<span class="hljs-number">1</span>]+=res[i]/<span class="hljs-number">10</span>;<br>      res[i]%=<span class="hljs-number">10</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过看 <a href="https://oi-wiki.org/math/bignum/#karatsuba-%E4%B9%98%E6%B3%95">OI Wiki</a> 上还介绍了一个 Karatsuba 乘法的方法，时间复杂度要<strong>小于竖式计算</strong>，我不介绍了，<del>我也看不懂</del>。</p><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>除法我感觉用的也不多（？）也许是我感觉，我还没用上，等我用到了再写吧。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>高精度</tag>
      
      <tag>C++</tag>
      
      <tag>算法竞赛</tag>
      
      <tag>高精度运算</tag>
      
      <tag>数值计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Hexo 和 Fluid 搭建一个漂亮的静态网页博客</title>
    <link href="/2024/02/01/building-a-static-website-with-hexo/"/>
    <url>/2024/02/01/building-a-static-website-with-hexo/</url>
    
    <content type="html"><![CDATA[<p>第一篇文章，当然是要记录一下怎么建的这个网站啦。<del>也没人告诉你第一篇必须写这个吧（</del></p><p>我的建站方案是 <code>Hexo</code> 和 <code>Fluid</code> 主题。我原本打算使用 <code>Jekyll</code> 作为生成静态博客的方案，不过后来我看到 <code>Hexo</code> 的功能更强大，插件更多，速度好像（也许真的更快？）也更快，还能一键部署，于是最终选择了 <code>Hexo</code> 作为静态网页的生成器。</p><p>本篇适用于刚刚接触 <code>Hexo</code> 和 <code>Markdown</code> 的零基础用户。本人水平不高，有问题也请指正。（评论功能正在开发）</p><p>闲话少说，我们进入正题。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 <code>Git</code></h2><p>安装 <code>Hexo</code> 之前需要先安装 <code>Git</code>。<code>Git</code> 是一个版本控制软件，由著名的 Linux 之父 Linus Torvalds 开发。<del>扯远了（</del></p><p>绝大多数 GNU&#x2F;Linux 发行版的仓库里都有 Git。Windows 用户可以从<a href="https://git-scm.com/downloads">官网</a>下载安装。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h2><p><code>Hexo</code> 是一个基于 <code>Node.JS</code> 的静态网页生成器。部署 <code>Hexo</code> 需要先安装 <code>Node.JS</code>，然后使用 <code>npm</code> 安装。</p><p>部分 GNU&#x2F;Linux 发行版已经在自己的软件包中添加了 <code>Hexo</code>，名字一般叫 <code>hexo-cli</code>，也可以从软件仓库中直接安装。（Arch Linux 的在 AUR 中）</p><p>Windows系统安装 <code>Node.JS</code> 时，记得勾选 <code>Add to PATH</code> 选项（默认已经勾选）</p><p>如果选择从 <code>npm</code> 安装，先设置国内镜像，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p><del>反正我是直接从 AUR 上安装 hexo-cli 的。</del></p><h2 id="部署网页源代码仓库"><a href="#部署网页源代码仓库" class="headerlink" title="部署网页源代码仓库"></a>部署网页源代码仓库</h2><p>新建一个空文件夹，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>npm install<br></code></pre></td></tr></table></figure><p><img src="/2024/02/01/building-a-static-website-with-hexo/hexo-init.png" alt="执行上述命令后的终端输出"></p><p>如果克隆 GitHub 仓库那一步比较慢或者连接失败，可以考虑加个代理。</p><p>然后你会发现目录下多了很多东西，这就是你的<strong>网页源代码仓库</strong>，大概有这些东西：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">_config.yml<br>node_modules<br>scaffolds<br>.github<br>package.json<br><span class="hljs-built_in">source</span><br>_config.landscape.yml<br>.gitignore<br>package-lock.json<br>themes<br></code></pre></td></tr></table></figure><p><code>Hexo</code> 默认有一个很简单<del>粗暴</del>的页面，执行一下命令，可以启动本地服务器进行预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g <span class="hljs-comment"># 生成网页</span><br>hexo s <span class="hljs-comment"># 启动本地服务器</span><br></code></pre></td></tr></table></figure><p>浏览器访问 <code>http://localhost:4000</code> 即可看到你的第一个博客页面。</p><p><img src="/2024/02/01/building-a-static-website-with-hexo/hexo-sample.png" alt="默认的页面，采用默认的 Landscape 主题，简单干净"></p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>终端进入源代码文件夹，执行以下命令可以创建一篇文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>post</code> 和 <code>My New Post</code> 可以根据实际情况修改。详细信息可以查阅<a href="https://hexo.io/zh-cn/docs/writing">官方文档</a>。</p><p>然后 <code>source</code> 文件夹中会出现一个 <code>My New Post.md</code> 文件，就可以使用 Markdown 编辑器在该文件中撰写文章了。</p><p>写完后运行 <code>hexo g</code> 将文章渲染即可。然后你就能通过 <code>hexo s</code> 看到你的网页的更改了。</p><p><img src="/2024/02/01/building-a-static-website-with-hexo/my-new-post-sample-blog.png" alt="写好的内容呈现的就是这样子"></p><h2 id="部署到-Git-Pages"><a href="#部署到-Git-Pages" class="headerlink" title="部署到 Git Pages"></a>部署到 Git Pages</h2><p>Git Pages 是一个托管静态网站的最佳选择。这个可能没听说过，GitHub Pages 一定听说过吧。<code>Hexo</code> 可以<strong>一键部署</strong>到这样的静态网站托管服务上去。</p><p>首先按照托管商的文档设置好仓库。具体怎么做取决于你要怎么去托管。以 Github Pages 为例，可以参照<a href="https://docs.github.com/zh/pages/getting-started-with-github-pages/creating-a-github-pages-site">官方文档</a>来建立一个 Github Pages 仓库。</p><p>然后在源代码文件夹下安装 <code>hexo-deployer-git</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后修改 <code>_config.yml</code> 文件末尾的 <code>Deployment</code> 部分，修改成如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">填写仓库</span> <span class="hljs-string">Git</span> <span class="hljs-string">链接</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">填写仓库分支</span><br></code></pre></td></tr></table></figure><p>GitHub 要求分支为 <code>master</code>，Codeberg 要求分支为 <code>pages</code>，其他请参照对应服务商的要求。</p><p>完成后运行 <code>hexo d</code> 将网站上传部署。</p><h2 id="安装-Fluid-主题"><a href="#安装-Fluid-主题" class="headerlink" title="安装 Fluid 主题"></a>安装 Fluid 主题</h2><p><code>Fluid</code> 是一个非常漂亮的 Material Design 风格的（<del>感觉不太像 MD</del>）响应式主题，本站采用的就是 Fluid 主题。</p><p>安装 Fluid 主题也非常简单，由于现在安装的 Hexo 基本都是 5.0.0 以上的版本，我直接按照官方推荐的方式，通过 <code>npm</code> 直接安装。</p><ol><li><p>进入博客目录执行命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p> 然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的<a href="https://github.com/fluid-dev/hexo-theme-fluid/raw/master/_config.yml">配置文件</a>的内容放进去。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl https://github.com/fluid-dev/hexo-theme-fluid/raw/master/_config.yml -o _config.fluid.yml<br><span class="hljs-comment"># GitHub 要是慢，可以用 GitHub 加速或者使用代理</span><br></code></pre></td></tr></table></figure><p> 然后配置 <code>_config.fluid.yml</code> 。</p></li><li><p>指定主题</p><p> 如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p> 生成的网页应该是这样：</p><p> <img src="/2024/02/01/building-a-static-website-with-hexo/hexo-fluid-sample-blog.png" alt="Fluid 初始页面"></p></li><li><p>创建「关于页」</p><p> 首次使用主题的「关于页」需要手动创建：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p> 创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><p> 修改后的文件示例如下：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p> 这里写关于页的正文，支持 Markdown, HTML。</p><p> 效果应该是这样的：</p><p> <img src="/2024/02/01/building-a-static-website-with-hexo/hexo-fluid-about-sample.png" alt="关于页面初始样式"></p></li></ol><p>更多的配置和参数可以参照<a href="https://hexo.fluid-dev.com/docs/">官方文档</a>，这里就不多说啦。</p><p>于是呢，一个简单的静态博客就配置好了！</p><p>就这样。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网站</tag>
      
      <tag>建站</tag>
      
      <tag>Hexo</tag>
      
      <tag>静态博客</tag>
      
      <tag>静态网页</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到 GT610 的小仓库！</title>
    <link href="/2024/02/01/hello-world/"/>
    <url>/2024/02/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>总觉得有时候得记录点什么，于是就开了这个小博客，不管有没有人看，我会坚持写下去的。</p><p>我是 <code>GT610</code>，也叫 <code>二次率战术核显</code>，也有人叫我 <code>核显</code>，不过这个都不重要啦。</p><p>不定期发一些技术向的教程，或者随便吐槽两句。</p><p>就这样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
